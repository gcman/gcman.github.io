+++
title = "Project Euler 12: Highly Divisible Triangular Number"
author = ["Gautam Manohar"]
description = "My solution to problem 12 of Project Euler."
date = 2018-06-10
tags = ["primes"]
categories = ["euler"]
draft = false
+++

## Problem Statement {#problem-statement}

The sequence of triangle numbers is generated by adding the natural numbers. So
the 7th triangle number would be \\(1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\\). The first ten
terms would be:

\begin{equation\*}
1, 3, 6, 10, 15, 21, 28, 36, 45, 55,\ldots
\end{equation\*}

What is the value of the first triangle number to have over \\(N\\) divisors?


## My Algorithm {#my-algorithm}

If we prime factor a number \\(n\\) as

\begin{equation}
p\_1^{e\_{1}}p\_2^{e\_2} \cdots p\_n^{e\_n},
\end{equation}

then we can write the number of factors of \\(n\\) as

\begin{equation}
(e\_1 + 1)(e\_2+1) \cdots (e\_n+1).
\label{factor-prod}
\end{equation}

The \\(n\\)-th triangular number is \\(\frac{n(n+1)}{2} = O(n^2)\\). We could prime
factor this number in \\(O(n\log\log n)\\) time. But because \\(n\\) and \\(n+1\\) are
always coprime, the number of factors of \\(n(n+1)\\) is the product of the number
of factors of \\(n\\) and \\(n+1\\), which we can find in \\(O(\sqrt{n}\log\log n)\\) time.

To find the number of factors of the \\(n\\)-th triangular number, we also need to
account for the factors lost by dividing by 2. Exactly one of \\(n\\) and \\(n+1\\) is
divisible by 2, so we need not factor \\(n(n+1)\\). If the greatest power of 2 that
divides \\(n(n+1)\\) is \\(2^k\\), then the \\(n\\)-th triangular number has
\\(\frac{k}{k+1}\\) fewer factors than \\(n(n+1)\\).

We iterate over \\(\frac{n(n+1)}{2}\\) until a number with more than \\(N\\) divisors is
found. We can improve this solution by precomputing a sufficiently large list of
primes. W can decrease the constant factor in our algorithm by 2 if we cache
the number of prime factors of the last \\(n+1\\) that we tested.

A rough upper bound on our time complexity is \\(O(M)\\). First, we
generate the primes up to \\(\sqrt{M}\\) with complexity \\(O(\sqrt{M}\log \log M)\\).
Then we find the number of factors of a number at most \\(M\\), and we do this
\\(M\\) times. That is, for each of the \\(\frac{M}{\log M}\\) primes \\(p\\) we generated, we
find the number of times \\(p\\) divides \\(M\\), which is at most \\(\log\_p M\\). This
gives complexity \\(O(\sqrt{M}\log \log M + \frac{M}{\log M}\log M) = O(M)\\).