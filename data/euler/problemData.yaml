'1': {code: "def triangular(n):\n    \"\"\"Implement eq. (1)\"\"\"\n    return n *\
    \ (n+1) // 2\n\n\ndef sum_under(n, m):\n    \"\"\"Terms in eq. (3)\"\"\"\n   \
    \ return m*triangular((n-1)//m)\n\n\nT = int(input())\nfor _ in range(T):\n  \
    \  N = int(input())\n    print(sum_under(N, 3) + sum_under(N, 5) - sum_under(N,\
    \ 15))", comments: '0', difficulty: '5', empty: '4', hrdifficulty: Easy, memory: '930',
  name: Multiples of 3 and 5, num: '1', path: 1-Multiples-of-3-and-5, runtime: '3'}
'10': {code: "def bs(arr, l, r, x):\n    \"\"\"Binary Search arr from index l to r\
    \ for x\"\"\"\n    while l <= r:\n        mid = l + (r - l)//2\n        if arr[mid]\
    \ == x:\n            return mid\n        elif arr[mid] < x:\n            l = mid\
    \ + 1\n        else:\n            r = mid - 1\n    return r\n\n\ndef primes(n):\n\
    \    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes = []\n    sieve = [True] *\
    \ (n + 1)\n    for p in range(2, n + 1):\n        if sieve[p]:\n            primes.append(p)\n\
    \            # Cross out all multiples of p\n            for i in range(p * p,\
    \ n + 1, p):\n                sieve[i] = False\n    return primes\n\n\nPRIMES\
    \ = primes(int(2e6))\n# Construct the prefix sum array\nP = [0]\ncount = 0\nfor\
    \ p in PRIMES:\n    count += p\n    P.append(count)\ndel P[0]\n\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())\n    idx = bs(PRIMES, 0, len(PRIMES)-1,\
    \ N)\n    print(P[idx])", comments: '2', difficulty: '5', empty: '5', hrdifficulty: Medium,
  memory: '3064', name: Summation of Primes, num: '10', path: 10-Summation-of-Primes,
  runtime: '50'}
'100': {difficulty: '30', hrdifficulty: Advanced, name: Arranged probability, num: '100'}
'101': {difficulty: '35', hrdifficulty: Medium, name: Optimum polynomial}
'102': {difficulty: '15', hrdifficulty: Easy, name: Triangle containment}
'103': {difficulty: '45', hrdifficulty: Easy, name: 'Special subset sums: optimum'}
'104': {difficulty: '25', hrdifficulty: Easy, name: Pandigital Fibonacci ends}
'105': {difficulty: '45', hrdifficulty: Easy, name: 'Special subset sums: testing'}
'106': {difficulty: '50', hrdifficulty: Easy, name: 'Special subset sums: meta-testing'}
'107': {difficulty: '35', hrdifficulty: Easy, name: Minimal network}
'108': {difficulty: '30', hrdifficulty: Easy, name: Diophantine reciprocals I}
'109': {difficulty: '45', hrdifficulty: Easy, name: Darts}
'11': {code: "def prod(arr):\n    \"\"\"Compute the product of the numbers in arr\"\
    \"\"\n    ans = 1\n    for x in arr:\n        ans *= x\n    return ans\n\n\nG\
    \ = [list(map(int, input().split())) for _ in range(20)]\nans = 0\nfor y in range(20):\n\
    \    for x in range(20):\n        # Read rightwards\n        if x < 17:\n    \
    \        horiz = prod([G[x+i][y] for i in range(4)])\n        else:\n        \
    \    horiz = 0\n        # Read downwards\n        if y < 17:\n            vert\
    \ = prod([G[x][y+i] for i in range(4)])\n        else:\n            vert = 0\n\
    \        # Read down and to the right\n        if x < 17 and y < 17:\n       \
    \     ldiag = prod([G[x+i][y+i] for i in range(4)])\n        else:\n         \
    \   ldiag = 0\n        # Read down and to the left\n        if x >= 3 and y <\
    \ 17:\n            rdiag = prod([G[x-i][y+i] for i in range(4)])\n        else:\n\
    \            rdiag = 0\n        ans = max(ans, horiz, vert, ldiag, rdiag)\nprint(ans)",
  comments: '4', difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '954', name: Largest
    Product in a Grid, num: '11', path: 11-Largest-Product-in-a-Grid, runtime: '6'}
'110': {difficulty: '40', hrdifficulty: Easy, name: Diophantine reciprocals II}
'111': {difficulty: '45', hrdifficulty: Easy, name: Primes with runs}
'112': {difficulty: '15', hrdifficulty: Advanced, name: Bouncy numbers}
'113': {difficulty: '30', hrdifficulty: Easy, name: Non-bouncy numbers}
'114': {difficulty: '35', hrdifficulty: Medium, name: Counting block combinations
    I}
'115': {difficulty: '35', hrdifficulty: Medium, name: Counting block combinations
    II}
'116': {difficulty: '30', hrdifficulty: Easy, name: 'Red, green or blue tiles'}
'117': {difficulty: '35', hrdifficulty: Easy, name: 'Red, green, and blue tiles'}
'118': {difficulty: '45', hrdifficulty: Hard, name: Pandigital prime sets}
'119': {difficulty: '30', hrdifficulty: Easy, name: Digit power sum}
'12': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes =\
    \ []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if\
    \ sieve[p]:\n            primes.append(p)\n            # Cross out all multiples\
    \ of p\n            for i in range(p * p, n + 1, p):\n                sieve[i]\
    \ = False\n    return primes\n\n\nP = primes(202)\n\n\ndef prime_factors(n):\n\
    \    \"\"\"Return the prime factorization of n\"\"\"\n    factors = {}\n    for\
    \ p in P:\n        if n % p == 0:\n            factors[p] = 0\n            while\
    \ n % p == 0:\n                n //= p\n                factors[p] += 1\n    return\
    \ factors\n\n\n# Memoize the latest num_of_factors\nLATEST = [0, 0]\n\n\ndef factors(n):\n\
    \    \"\"\"Find the number of factors of n\"\"\"\n    global LATEST\n    if n\
    \ == LATEST[0]:\n        return LATEST[1]\n    P = prime_factors(n)\n    ans =\
    \ 1\n    for x in P:\n        ans *= P[x] + 1\n        LATEST = [n, ans]\n   \
    \ return ans\n\n\ndef triangle_factors(n):\n    \"\"\"Find the number of factors\
    \ of T_n\"\"\"\n    k = prime_factors((n//2 + n % 2) * 2)[2]\n    return factors(n)\
    \ * factors(n+1) * k // (k+1)\n\n\nT = int(input())\nfor _ in range(T):\n    N\
    \ = int(input())\n    i = 1\n    while triangle_factors(i) <= N:\n        i +=\
    \ 1\n        print(i*(i+1)//2)", comments: '2', difficulty: '5', empty: '12',
  hrdifficulty: Easy, memory: '952', name: Highly Divisible Triangular Number, num: '12',
  path: 12-Highly-Divisible-Triangular-Number, runtime: '17'}
'120': {difficulty: '25', hrdifficulty: Easy, name: Square remainders}
'121': {difficulty: '35', hrdifficulty: Easy, name: Disc game prize fund}
'122': {difficulty: '40', hrdifficulty: Easy, name: Efficient exponentiation}
'123': {difficulty: '30', hrdifficulty: Easy, name: Prime square remainders}
'124': {difficulty: '25', hrdifficulty: Advanced, name: Ordered radicals}
'125': {difficulty: '25', hrdifficulty: Easy, name: Palindromic sums}
'126': {difficulty: '55', hrdifficulty: Advanced, name: Cuboid layers}
'127': {difficulty: '50', hrdifficulty: Advanced, name: abc-hits}
'128': {difficulty: '55', hrdifficulty: Hard, name: Hexagonal tile differences}
'129': {difficulty: '45', hrdifficulty: Hard, name: Repunit divisibility}
'13': {code: 'print(str(sum([int(input()) for _ in range(int(input()))]))[:10]', comments: '0',
  difficulty: '5', empty: '0', hrdifficulty: Easy, memory: '937', name: Large Sum,
  num: '13', path: 13-Large-Sum, runtime: '6'}
'130': {difficulty: '45', hrdifficulty: Easy, name: Composites with prime repunit
    property}
'131': {difficulty: '40', hrdifficulty: Hard, name: Prime cube partnership}
'132': {difficulty: '45', hrdifficulty: Advanced, name: Large repunit factors}
'133': {difficulty: '50', hrdifficulty: Medium, name: Repunit nonfactors}
'134': {difficulty: '45', hrdifficulty: Medium, name: Prime pair connection}
'135': {difficulty: '45', hrdifficulty: Medium, name: Same differences}
'136': {difficulty: '50', hrdifficulty: Hard, name: Singleton difference}
'137': {difficulty: '50', hrdifficulty: Easy, name: Fibonacci golden nuggets}
'138': {difficulty: '45', hrdifficulty: Easy, name: Special isosceles triangles}
'139': {difficulty: '50', hrdifficulty: Easy, name: Pythagorean tiles}
'14': {code: "def bs(arr, l, r, x):\n    \"\"\"Binary Search arr from index l to r\
    \ for x\"\"\"\n    while l <= r:\n        mid = l + (r - l)//2\n        if arr[mid]\
    \ == x:\n            return arr[mid]\n        elif arr[mid] < x:\n           \
    \ l = mid + 1\n        else:\n            r = mid - 1\n    return arr[r]\n\n\n\
    # Initialize the memoization list\nMAX = int(5e6)\nmemo = [0]*(MAX + 1)\nmemo[1]\
    \ = 1\n# List of indices at which there is a new maximum\nmax_list = [1]\n\n\n\
    def collatz(n):\n    \"\"\"Generate collatz chain starting with n\"\"\"\n    #\
    \ Store chain length of small n in memory\n    if n <= MAX:\n        if memo[n]\
    \ == 0:\n            if n % 2 == 0:\n                # Use bitshift by 1 for speed\n\
    \                memo[n] = collatz(n >> 1) + 1\n            else:\n          \
    \      memo[n] = collatz(3*n+1) + 1\n        return memo[n]\n    # Otherwise compute\
    \ on the fly\n    elif n % 2 == 0:\n        return collatz(n >> 1) + 1\n    return\
    \ collatz(3*n+1) + 1\n\n\nfor i in range(2, MAX+1):\n    collatz(i)\n    # Track\
    \ right-maximal indices\n    if memo[i] >= memo[max_list[-1]]:\n        max_list.append(i)\n\
    \nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(bs(max_list,\
    \ 0, len(max_list)-1, N))", comments: '6', difficulty: '5', empty: '7', hrdifficulty: Easy,
  memory: '5603', name: Longest Collatz Sequence, num: '14', path: 14-Longest-Collatz-Sequence,
  runtime: '493'}
'140': {difficulty: '55', hrdifficulty: Easy, name: Modified Fibonacci golden nuggets}
'141': {difficulty: '60', hrdifficulty: Hard, name: 'Investigating progressive numbers,
    n, which are also square'}
'142': {difficulty: '45', hrdifficulty: Easy, name: Perfect Square Collection}
'143': {difficulty: '65', hrdifficulty: Easy, name: Investigating the Torricelli point
    of a triangle}
'144': {difficulty: '50', hrdifficulty: Medium, name: Investigating multiple reflections
    of a laser beam}
'145': {difficulty: '20', hrdifficulty: Hard, name: 'How many reversible numbers are
    there below one-billion?'}
'146': {difficulty: '50', hrdifficulty: Easy, name: Investigating a Prime Pattern}
'147': {difficulty: '65', hrdifficulty: Hard, name: Rectangles in cross-hatched grids}
'148': {difficulty: '50', hrdifficulty: Hard, name: Exploring Pascal's triangle}
'149': {difficulty: '50', hrdifficulty: Hard, name: Searching for a maximum-sum subsequence}
'15': {code: "def inv(a, p):\n    \"\"\"Modular inverse with Fermat's Little Theorem\"\
    \"\"\n    return pow(a, p-2, p)\n\n\ndef choose(n, k, p):\n    \"\"\"n choose\
    \ k mod p\"\"\"\n    ans = 1\n    # Recurrence in eq. (2)\n    for i in range(k):\n\
    \        ans = (ans * (n-i) * inv(i+1, p)) % p\n    return ans\n\n\nP = 1000000007\n\
    T = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n \
    \   print(choose(N+M, min(N, M), P))", comments: '1', difficulty: '5', empty: '4',
  hrdifficulty: Easy, memory: '923', name: Lattice Paths, num: '15', path: 15-Lattice-Paths,
  runtime: '4'}
'150': {difficulty: '55', hrdifficulty: Easy, name: Searching a triangular array for
    a sub-triangle having minimum-sum}
'151': {difficulty: '50', hrdifficulty: Medium, name: 'Paper sheets of standard sizes:
    an expected-value problem'}
'152': {difficulty: '65', hrdifficulty: Advanced, name: Writing 1/2 as a sum of inverse
    squares}
'153': {difficulty: '65', hrdifficulty: Hard, name: Investigating Gaussian Integers}
'154': {difficulty: '65', hrdifficulty: Hard, name: Exploring Pascal's pyramid}
'155': {difficulty: '60', hrdifficulty: Easy, name: Counting Capacitor Circuits}
'156': {difficulty: '70', hrdifficulty: Medium, name: Counting Digits}
'157': {difficulty: '65', hrdifficulty: Hard, name: Solving the diophantine equation
    1/a+1/b= p/10n}
'158': {difficulty: '55', hrdifficulty: Medium, name: Exploring strings for which
    only one character comes lexicographically after its neighbour to the left}
'159': {difficulty: '60', hrdifficulty: Medium, name: Digital root sums of factorisations}
'16': {code: "def digit_sum(n):\n    \"\"\"Sum of digits of n\"\"\"\n    s = 0\n \
    \   while n > 0:\n        s += n % 10\n        n = (n - n % 10) // 10\n    return\
    \ s\n\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(digit_sum(pow(2,\
    \ N)))", comments: '0', difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '917',
  name: Power Digit Sum, num: '16', path: 16-Power-Digit-Sum, runtime: '4'}
'160': {difficulty: '60', hrdifficulty: Advanced, name: Factorial trailing digits}
'161': {difficulty: '70', hrdifficulty: Hard, name: Triominoes}
'162': {difficulty: '45', hrdifficulty: Medium, name: Hexadecimal numbers}
'163': {difficulty: '70', hrdifficulty: Easy, name: Cross-hatched triangles}
'164': {difficulty: '45', hrdifficulty: Easy, name: Numbers for which no three consecutive
    digits have a sum greater than a given value}
'165': {difficulty: '65', hrdifficulty: Easy, name: Intersections}
'166': {difficulty: '50', hrdifficulty: Easy, name: Criss Cross}
'167': {difficulty: '75', hrdifficulty: Easy, name: Investigating Ulam sequences}
'168': {difficulty: '65', hrdifficulty: Easy, name: Number Rotations}
'169': {difficulty: '50', hrdifficulty: Easy, name: Exploring the number of different
    ways a number can be expressed as a sum of powers of 2}
'17': {code: "# Special names\nNUMS = {0: \"zero\", 1: \"one\", 2: \"two\", 3: \"\
    three\", 4: \"four\", 5: \"five\",\n        6: \"six\", 7: \"seven\", 8: \"eight\"\
    , 9: \"nine\", 10: \"ten\",\n        11: \"eleven\", 12: \"twelve\", 13: \"thirteen\"\
    , 14: \"fourteen\",\n        15: \"fifteen\", 16: \"sixteen\", 17: \"seventeen\"\
    , 18: \"eighteen\",\n        19: \"nineteen\", 20: \"twenty\", 30: \"thirty\"\
    , 40: \"forty\", 50: \"fifty\",\n        60: \"sixty\", 70: \"seventy\", 80: \"\
    eighty\", 90: \"ninety\"}\nTEN_POW = [\"one\", \"ten\", \"hundred\", \"thousand\"\
    ,\n           \"million\", \"billion\", \"trillion\"]\nUPPERCASE = True\n\n\n\
    def three_dig_name(n):\n    \"\"\"English name of a three-digit number\"\"\"\n\
    \    if n in NUMS:\n        return NUMS[n]\n    else:\n        # Start building\
    \ name\n        name = []\n        # Check if hundreds digit exists\n        if\
    \ n // 100 > 0:\n            # 342 -> \"three hundred\"\n            name.append(NUMS[n//100])\n\
    \            name.append(TEN_POW[2])\n        # Check if we know this number\n\
    \        if n % 100 in NUMS:\n            name.append(NUMS[n % 100])\n       \
    \ else:\n            # The tens digit\n            # 342 -> 42 - 2\n         \
    \   if (n % 100) - (n % 10) > 0:\n                name.append(NUMS[(n % 100) -\
    \ (n % 10)])\n            # Ones digit\n            if n % 10 > 0:\n         \
    \       name.append(NUMS[n % 10])\n        return \" \".join(name)\n\n\ndef num_name(n):\n\
    \    \"\"\"English name of a number\"\"\"\n    # Split up into 5 blocks of 3 digits\n\
    \    blocks = [(n // 1000**i) % 1000 for i in range(0, 5)]\n    name = []\n  \
    \  # Start from largest block (it goes first in the name)\n    for i, block in\
    \ enumerate(reversed(blocks)):\n        if block > 0:\n            # Get the three\
    \ digit name\n            block_name = three_dig_name(block)\n            name.append(block_name)\n\
    \            if i != 4:\n                # When i = 4, this is the smallest block\n\
    \                name.append(TEN_POW[-i-1])\n    return \" \".join(name)\n\n\n\
    T = int(input())\nfor _ in range(T):\n    N = int(input())\n    name = num_name(N)\n\
    \    if UPPERCASE:\n        # Capitalize first letters\n        name = name.title()\n\
    \    print(name)", comments: '13', difficulty: '5', empty: '6', hrdifficulty: Easy,
  memory: '952', name: Number Letter Counts, num: '17', path: 17-Number-Letter-Counts,
  runtime: '4'}
'170': {difficulty: '70', hrdifficulty: Easy, name: Find the largest 0 to 9 pandigital
    that can be formed by concatenating products}
'171': {difficulty: '65', hrdifficulty: Medium, name: Finding numbers for which the
    sum of the squares of the digits is a square}
'172': {difficulty: '55', hrdifficulty: Expert, name: Investigating numbers with few
    repeated digits}
'173': {difficulty: '30', hrdifficulty: Medium, name: 'Using up to one million tiles
    how many different "hollow" square laminae can be formed?'}
'174': {difficulty: '40', hrdifficulty: Easy, name: 'Counting the number of "hollow"
    square laminae that can form one, two, three, ... distinct arrangements'}
'175': {difficulty: '70', hrdifficulty: Medium, name: Fractions involving the number
    of different ways a number can be expressed as a sum of powers of 2}
'176': {difficulty: '70', hrdifficulty: Medium, name: Right-angled triangles that
    share a cathetus}
'177': {difficulty: '80', hrdifficulty: Hard, name: Integer angled Quadrilaterals}
'178': {difficulty: '55', hrdifficulty: Medium, name: Step Numbers}
'179': {difficulty: '25', hrdifficulty: Easy, name: Consecutive positive divisors}
'18': {code: "def parents(i, j):\n    \"\"\"Indices of adjacent entries to (i,j) in\
    \ row above\"\"\"\n    out = []\n    if j < i:\n        out.append(j)\n    if\
    \ 0 < j:\n        out.append(j-1)\n    return out\n\n\ndef max_sum(arr):\n   \
    \ \"\"\"Maximal path sum down triangular array\"\"\"\n    # The previous rows\
    \ max_sums\n    parent = []\n    for i, row in enumerate(arr):\n        curr =\
    \ []\n        if i == 0:\n            # Handle the case where there are no parents\n\
    \            curr = [row[0]]\n        else:\n            # Get the higher parent\
    \ sum and add the current entry\n            for j, elem in enumerate(row):\n\
    \                curr.append(elem + max([parent[x] for x in parents(i, j)]))\n\
    \        # We're done with the row\n        # So move it into memory for the next\
    \ row\n        parent = curr\n    return max(parent)\n\n\nT = int(input())\nfor\
    \ _ in range(T):\n    N = int(input())\n    rows = [list(map(int, input().split()))\
    \ for _ in range(N)]\n    ans = max_sum(rows)\n    print(ans)", comments: '5',
  difficulty: '5', empty: '4', hrdifficulty: Easy, memory: '932', name: Maximum Path
    Sum I, num: '18', path: 18-Maximum-Path-Sum-I, runtime: '6'}
'180': {difficulty: '75', hrdifficulty: Medium, name: Rational zeros of a function
    of three variables}
'181': {difficulty: '70', hrdifficulty: Easy, name: Investigating in how many ways
    objects of two different colours can be grouped}
'182': {difficulty: '60', hrdifficulty: Expert, name: RSA encryption}
'183': {difficulty: '45', hrdifficulty: Easy, name: Maximum product of parts}
'184': {difficulty: '75', hrdifficulty: Hard, name: Triangles containing the origin}
'185': {difficulty: '55', hrdifficulty: Medium, name: Number Mind}
'186': {difficulty: '60', hrdifficulty: Easy, name: Connectedness of a network}
'187': {difficulty: '25', hrdifficulty: Medium, name: Semiprimes}
'188': {difficulty: '35', hrdifficulty: Expert, name: The hyperexponentiation of a
    number}
'189': {difficulty: '70', hrdifficulty: Easy, name: Tri-colouring a triangular grid}
'19': {difficulty: '5', hrdifficulty: Easy, name: Counting Sundays, num: '19'}
'190': {difficulty: '50', hrdifficulty: Hard, name: Maximising a weighted product}
'191': {difficulty: '35', hrdifficulty: Easy, name: Prize Strings}
'192': {difficulty: '75', hrdifficulty: Hard, name: Best Approximations}
'193': {difficulty: '55', hrdifficulty: Medium, name: Squarefree Numbers}
'194': {difficulty: '75', hrdifficulty: Expert, name: Coloured Configurations}
'195': {difficulty: '75', hrdifficulty: Hard, name: Inscribed circles of triangles
    with one angle of 60 degrees}
'196': {difficulty: '65', hrdifficulty: Medium, name: Prime triplets}
'197': {difficulty: '45', hrdifficulty: Easy, name: Investigating the behaviour of
    a recursively defined sequence}
'198': {difficulty: '80', hrdifficulty: Expert, name: Ambiguous Numbers}
'199': {difficulty: '70', hrdifficulty: Easy, name: Iterative Circle Packing}
'2': {code: "def next_even(f):\n    \"\"\"Implement eq. (5)\"\"\"\n    return 4*f[1]\
    \ + f[0]\n\n\ndef even_fib_sum(n):\n    \"\"\"Find the sum of even Fibonacci numbers\
    \ up to n\"\"\"\n    fib = [0, 2]  # Start with first two evens\n    if n >= 2:\n\
    \        count = 2\n    else:\n        count = 0\n    # Go up to the maximum\n\
    \    while next_even(fib) <= n:\n        count += next_even(fib)\n        # Keep\
    \ track of last two evens\n        fib = [fib[1], next_even(fib)]\n    return\
    \ count\n\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(even_fib_sum(N))",
  comments: '3', difficulty: '5', empty: '4', hrdifficulty: Easy, memory: '922', name: Even
    Fibonacci Numbers, num: '2', path: 2-Even-Fibonacci-Numbers, runtime: '3'}
'20': {code: "from math import factorial\n\n\ndef digit_sum(n):\n    return sum([int(x)\
    \ for x in str(n)])\n\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n\
    \    print(digit_sum(factorial(N)))", comments: '0', difficulty: '5', empty: '4',
  hrdifficulty: Easy, memory: '930', name: Factorial Digit Sum, num: '20', path: 20-Factorial-Digit-Sum,
  runtime: '4'}
'200': {difficulty: '65', hrdifficulty: Medium, name: Find the 200th prime-proof sqube
    containing the contiguous sub-string "200"}
'201': {difficulty: '65', hrdifficulty: Easy, name: Subsets with a unique sum}
'202': {difficulty: '60', hrdifficulty: Hard, name: Laserbeam}
'203': {difficulty: '25', hrdifficulty: Medium, name: Squarefree Binomial Coefficients}
'204': {difficulty: '30', hrdifficulty: Medium, name: Generalised Hamming Numbers}
'205': {difficulty: '15', hrdifficulty: Hard, name: Dice Game}
'206': {difficulty: '5', hrdifficulty: Easy, name: Concealed Square}
'207': {difficulty: '40', hrdifficulty: Easy, name: Integer partition equations}
'208': {difficulty: '70', hrdifficulty: Expert, name: Robot Walks}
'209': {difficulty: '60', hrdifficulty: Hard, name: Circular Logic}
'21': {code: "from math import sqrt\n\n\ndef divisor_sum(n):\n    \"\"\"Sum of divisors\
    \ of n\"\"\"\n    s = 0\n    for i in range(1, int(sqrt(n))+1):\n        if n\
    \ % i == 0:\n            s += i\n            if i != n//i:\n                s\
    \ += n//i\n    return s - n\n\n\nMAX = int(1e5)\n# Precompute all amicable numbers\n\
    AMICABLE = set()\nfor x in range(1, MAX+1):\n    friend = divisor_sum(x)\n   \
    \ # Check if x = d(d(x)) and x != d(x)\n    if x == divisor_sum(friend) and x\
    \ != friend:\n        # Avoid duplicates\n        AMICABLE.add(x)\n\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())\n    S = sum([x for x in AMICABLE if\
    \ x < N])\n    print(S)", comments: '3', difficulty: '5', empty: '5', hrdifficulty: Easy,
  memory: '936', name: Amicable Numbers, num: '21', path: 21-Amicable-Numbers, runtime: '183'}
'210': {difficulty: '70', hrdifficulty: Medium, name: Obtuse Angled Triangles}
'211': {difficulty: '50', hrdifficulty: Hard, name: Divisor Square Sum}
'212': {difficulty: '70', hrdifficulty: Expert, name: Combined Volume of Cuboids}
'213': {difficulty: '60', hrdifficulty: Medium, name: Flea Circus}
'214': {difficulty: '40', hrdifficulty: Hard, name: Totient Chains}
'215': {difficulty: '50', name: Crack-free Walls}
'216': {difficulty: '45', name: Investigating the primality of numbers of the form
    2n2-1}
'217': {difficulty: '70', name: Balanced Numbers}
'218': {difficulty: '55', name: Perfect right-angled triangles}
'219': {difficulty: '70', name: Skew-cost coding}
'22': {code: "import sys\n# We use this to speed up reading stdin\n# Because we have\
    \ a lot of names to read\ninput = sys.stdin.readline\n\n# Reference alphabet\n\
    ALPH = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef score(s):\n    \"\"\"Name score\
    \ of string s\"\"\"\n    # index starts at 0\n    # So score is the sum of (index\
    \ + 1) for each letter\n    return sum([ALPH.index(x) for x in s]) + len(s)\n\n\
    \nN = int(input())\nnames = sorted([input().strip() for _ in range(N)])\nQ = int(input())\n\
    for _ in range(Q):\n    # Remove any possible whitespace\n    name = input().strip()\n\
    \    # Index starts at 0\n    ans = score(name)*(names.index(name) + 1)\n    print(ans)",
  comments: '7', difficulty: '5', empty: '5', hrdifficulty: Easy, memory: '974', name: Names
    Scores, num: '22', path: 22-Names-Scores, runtime: '30'}
'220': {difficulty: '55', name: Heighway Dragon}
'221': {difficulty: '65', name: Alexandrian Integers}
'222': {difficulty: '60', name: Sphere Packing}
'223': {difficulty: '70', name: Almost right-angled triangles I}
'224': {difficulty: '75', name: Almost right-angled triangles II}
'225': {difficulty: '45', name: Tribonacci non-divisors}
'226': {difficulty: '65', name: A Scoop of Blancmange}
'227': {difficulty: '65', name: The Chase}
'228': {difficulty: '70', name: Minkowski Sums}
'229': {difficulty: '70', name: Four Representations using Squares}
'23': {code: "def divisor_sum(n):\n    \"\"\"Sum of divisors of n\"\"\"\n    s = 0\n\
    \    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            s\
    \ += i\n            if i != n//i:\n                s += n//i\n    return s - n\n\
    \n\n# We don't need to go past this\nMAX = 28123\nABUNDANT = set()\nfor i in range(1,\
    \ MAX+1):\n    if i < divisor_sum(i):\n        ABUNDANT.add(i)\n\n\ndef abundant_sum(n):\n\
    \    \"\"\"Can n be written as the sum of abundant numbers?\"\"\"\n    if n >\
    \ 28123:\n        return True\n    # Find all the differences\n    diff = set(n\
    \ - x for x in ABUNDANT)\n    # Check if any of these differences are abundant\n\
    \    if diff & ABUNDANT:\n        return True\n    return False\n\n\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())\n    if abundant_sum(N):\n        print(\"\
    YES\")\n    else:\n        print(\"NO\")", comments: '3', difficulty: '5', empty: '6',
  hrdifficulty: Easy, memory: '1100', name: Non-abundant Sums, num: '23', path: 23-Non-Abundant-Sums,
  runtime: '21'}
'230': {difficulty: '50', name: Fibonacci Words}
'231': {difficulty: '40', name: The prime factorisation of binomial coefficients}
'232': {difficulty: '65', name: The Race}
'233': {difficulty: '70', name: Lattice points on a circle}
'234': {difficulty: '50', name: Semidivisible numbers}
'235': {difficulty: '40', name: An Arithmetic Geometric sequence}
'236': {difficulty: '80', name: Luxury Hampers}
'237': {difficulty: '70', name: Tours on a 4 x n playing board}
'238': {difficulty: '75', name: Infinite string tour}
'239': {difficulty: '65', name: Twenty-two Foolish Primes}
'24': {code: "from math import factorial\n\n\ndef lex_perm(n, s):\n    \"\"\"Find\
    \ n-th lexicographic permutation of s\"\"\"\n    # Write s in 'factorial base'\n\
    \    n %= factorial(len(s))\n    indices = []\n    # Start with big factorials\
    \ and subtract\n    for x in range(len(s)-1, -1, -1):\n        elem = n // factorial(x)\n\
    \        indices.append(elem)\n        n -= elem * factorial(x)\n    s = sorted(list(s))\n\
    \    out = \"\"\n    for i in indices:\n        # Remove the i-th remaining element\n\
    \        # i is the coeffcient in the\n        # factorial base expansion of n\n\
    \        out += s.pop(i)\n    return out\n\n\nS = \"abcdefghijklm\"\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())-1\n    print(lex_perm(N, S))", comments: '5',
  difficulty: '5', empty: '4', hrdifficulty: Easy, memory: '930', name: Lexicographic
    Permutations, num: '24', path: 24-Lexicographic-Permutations, runtime: '6'}
'240': {difficulty: '60', name: Top Dice}
'241': {difficulty: '80', name: Perfection Quotients}
'242': {difficulty: '75', name: Odd Triplets}
'243': {difficulty: '35', name: Resilience}
'244': {difficulty: '70', name: Sliders}
'245': {difficulty: '80', name: Coresilience}
'246': {difficulty: '80', name: Tangents to an ellipse}
'247': {difficulty: '65', name: Squares under a hyperbola}
'248': {difficulty: '70', name: "Numbers for which Euler\u2019s totient function equals\
    \ 13!"}
'249': {difficulty: '60', name: Prime Subset Sums}
'25': {code: "from math import ceil, log\n\n\ndef fib_dig(n):\n    \"\"\"First Fibonacci\
    \ number with n digits\"\"\"\n    # Implement eq. (6)\n    PHI = (1 + 5**0.5)/2\n\
    \    # Handle the one place our approximation fails\n    if n == 1:\n        return\
    \ 1\n    return ceil((n-1+log(5, 10)/2)/log(PHI, 10))\n\n\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())\n    print(fib_dig(N))", comments: '2',
  difficulty: '5', empty: '4', hrdifficulty: Easy, memory: '943', name: 1000-digit
    Fibonacci Number, num: '25', path: 25-1000-Digit-Fibonacci-Number, runtime: '7'}
'250': {difficulty: '55', name: '250250'}
'251': {difficulty: '70', name: Cardano Triplets}
'252': {difficulty: '80', name: Convex Holes}
'253': {difficulty: '75', name: Tidying up}
'254': {difficulty: '75', name: Sums of Digit Factorials}
'255': {difficulty: '75', name: Rounded Square Roots}
'256': {difficulty: '80', name: Tatami-Free Rooms}
'257': {difficulty: '85', name: Angular Bisectors}
'258': {difficulty: '70', name: A lagged Fibonacci sequence}
'259': {difficulty: '70', name: Reachable Numbers}
'26': {difficulty: '5', hrdifficulty: Easy, name: Reciprocal cycles, num: '26'}
'260': {difficulty: '70', name: Stone Game}
'261': {difficulty: '85', name: Pivotal Square Sums}
'262': {difficulty: '80', name: Mountain Range}
'263': {difficulty: '75', name: An engineers' dream come true}
'264': {difficulty: '85', name: Triangle Centres}
'265': {difficulty: '40', name: Binary Circles}
'266': {difficulty: '65', name: Pseudo Square Root}
'267': {difficulty: '50', name: Billionaire}
'268': {difficulty: '70', name: Counting numbers with at least four distinct prime
    factors less than 100}
'269': {difficulty: '80', name: Polynomials with at least one integer root}
'27': {code: "from math import sqrt\n\n\ndef primes(n):\n    \"\"\"Sieve of Eratosthenes\"\
    \"\"\n    primes = []\n    sieve = [True] * (n + 1)\n    for p in range(2, n +\
    \ 1):\n        if sieve[p]:\n            primes.append(p)\n            # Cross\
    \ out all multiples of p\n            for i in range(p * p, n + 1, p):\n     \
    \           sieve[i] = False\n    return primes\n\n\ndef is_prime(n):\n    \"\"\
    \"Trial division test: is n prime?\"\"\"\n    # We don't want negative primes\n\
    \    if n <= 0:\n        return False\n    return not any([n % i == 0 for i in\n\
    \                    range(2, int(sqrt(n))+1)])\n\n\nN = int(input())\nP = primes(N)\n\
    # The maximal no. of primes generated so far\nCOUNT = 0\n# The coefficients that\
    \ generate COUNT primes\nCOEFF = []\nfor a in range(1, N+1, 2):\n    for b in\
    \ P:\n        # Iterate over +/- a,b\n        for sgna in [-1, 1]:\n         \
    \   for sgnb in [-1, 1]:\n                # No. of primes given by a,b\n     \
    \           count = 0\n                # The quadratic given by a,b\n\n      \
    \          def f(x): return x*x + sgna*a*x + sgnb*b\n                # Keep going\
    \ until f(x) is not prime\n                while f(count) > 0 and is_prime(f(count)):\n\
    \                    count += 1\n                # Only keep the maximum so far\n\
    \                if count > COUNT:\n                    COUNT = count\n      \
    \              # Update coefficients\n                    COEFF = [sgna*a, sgnb*b]\n\
    print(\"{} {}\".format(COEFF[0], COEFF[1]))", comments: '10', difficulty: '5',
  empty: '7', hrdifficulty: Easy, memory: '931', name: Quadratic Primes, num: '27',
  path: 27-Quadratic-Primes, runtime: '165'}
'270': {difficulty: '80', name: Cutting Squares}
'271': {difficulty: '60', name: 'Modular Cubes, part 1'}
'272': {difficulty: '80', name: 'Modular Cubes, part 2'}
'273': {difficulty: '70', name: Sum of Squares}
'274': {difficulty: '65', name: Divisibility Multipliers}
'275': {difficulty: '85', name: Balanced Sculptures}
'276': {difficulty: '75', name: Primitive Triangles}
'277': {difficulty: '35', name: A Modified Collatz sequence}
'278': {difficulty: '50', name: Linear Combinations of Semiprimes}
'279': {difficulty: '60', name: Triangles with integral sides and an integral angle}
'28': {code: "def inv(a, m):\n    \"\"\"Modular inverse with Fermat's Little Theorem\"\
    \"\"\n    return pow(a, m-2, m)\n\n\ndef diag_sum(n, p):\n    \"\"\"Implement\
    \ eq. (4), mod p\"\"\"\n    return ((4*pow(n, 3, p) + 3*pow(n, 2, p) + 8*n - 9)*inv(6,\
    \ p)) % p\n\n\nT = int(input())\nP = 1000000007\nfor _ in range(T):\n    N = int(input())\n\
    \    print(diag_sum(N, P))", comments: '0', difficulty: '5', empty: '4', hrdifficulty: Easy,
  memory: '941', name: Number Spiral Diagonals, num: '28', path: 28-Number-Spiral-Diagonals,
  runtime: '6'}
'280': {difficulty: '65', name: Ant and seeds}
'281': {difficulty: '55', name: Pizza Toppings}
'282': {difficulty: '70', name: The Ackermann function}
'283': {difficulty: '75', name: Integer sided triangles for which the  area/perimeter
    ratio is integral}
'284': {difficulty: '55', name: Steady Squares}
'285': {difficulty: '55', name: Pythagorean odds}
'286': {difficulty: '50', name: Scoring probabilities}
'287': {difficulty: '40', name: Quadtree encoding (a simple compression algorithm)}
'288': {difficulty: '35', name: An enormous factorial}
'289': {difficulty: '90', name: Eulerian Cycles}
'29': {difficulty: '5', hrdifficulty: Easy, name: Distinct powers, num: '29'}
'290': {difficulty: '50', name: Digital Signature}
'291': {difficulty: '45', name: Panaitopol Primes}
'292': {difficulty: '65', name: Pythagorean Polygons}
'293': {difficulty: '30', name: Pseudo-Fortunate Numbers}
'294': {difficulty: '45', name: 'Sum of digits - experience #23'}
'295': {difficulty: '75', name: Lenticular holes}
'296': {difficulty: '60', name: Angular Bisector and Tangent}
'297': {difficulty: '35', name: Zeckendorf Representation}
'298': {difficulty: '60', name: Selective Amnesia}
'299': {difficulty: '60', name: Three similar triangles}
'3': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes = []\n\
    \    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if sieve[p]:\n\
    \            primes.append(p)\n            # Cross out all multiples of p\n  \
    \          for i in range(p * p, n + 1, p):\n                sieve[i] = False\n\
    \    return primes\n\n\ndef prime_factors(n):\n    \"\"\"Finds the prime factors\
    \ of n\"\"\"\n    factors = []\n    P = primes(int(n**0.5))\n    for p in P:\n\
    \        if n % p == 0:\n            factors.append(p)\n            # Divide out\
    \ all factors of p\n            while n % p == 0:\n                n //= p\n \
    \   if n != 1:\n        factors.append(n)\n    return factors\n\n\nT = int(input())\n\
    for _ in range(T):\n    N = int(input())\n    ans = max(prime_factors(N))\n  \
    \  print(ans)", comments: '2', difficulty: '5', empty: '4', hrdifficulty: Easy,
  memory: '1804', name: Largest Prime Factor, num: '3', path: 3-Largest-Prime-Factor,
  runtime: '16'}
'30': {code: "from itertools import combinations_with_replacement\nfrom collections\
    \ import Counter\nN = int(input())\n\nDIGITS = {}\n# Correspondence from x^N ->\
    \ x\nfor x in range(10):\n    DIGITS[x**N] = x\n\nans = 0\n# No answer has more\
    \ than 6 digits\nfor k in range(2, 7):\n    # Choose k elements from {0^N,...9^N}\
    \ with replacement\n    for candidate in combinations_with_replacement(DIGITS,\
    \ k):\n        # Get multiset of N-th roots of elements of combination\n     \
    \   digits_used = Counter(map(lambda x: DIGITS[x], candidate))\n        # Candidate\
    \ sum\n        S = str(sum(candidate))\n        # Get multiset of digits of candidate\
    \ sum\n        powers_used = Counter(map(int, S))\n        if digits_used == powers_used:\n\
    \            ans += int(S)\nprint(ans)", comments: '6', difficulty: '5', empty: '2',
  hrdifficulty: Easy, memory: '918', name: Digit Fifth Powers, num: '30', path: 30-Digit-Fifth-Powers,
  runtime: '15'}
'300': {difficulty: '50', name: Protein folding}
'301': {difficulty: '15', name: Nim}
'302': {difficulty: '60', name: Strong Achilles Numbers}
'303': {difficulty: '35', name: Multiples with small digits}
'304': {difficulty: '35', name: Primonacci}
'305': {difficulty: '60', name: Reflexive Position}
'306': {difficulty: '55', name: Paper-strip Game}
'307': {difficulty: '35', name: Chip Defects}
'308': {difficulty: '60', name: An amazing Prime-generating Automaton}
'309': {difficulty: '50', name: Integer Ladders}
'31': {code: "def count(coins, n):\n    \"\"\"Number of ways to write each m <= n\n\
    \    as a sum of elements of coins\"\"\"\n    # Initialize dp array\n    dp =\
    \ [0 for _ in range(n+1)]\n    # There is only one way to make nothing\n    dp[0]\
    \ = 1\n    for coin in coins:\n        for val in range(coin, n+1):\n        \
    \    dp[val] = (dp[val] + dp[val-coin]) % 1000000007\n    return dp\n\n\nCOINS\
    \ = [1, 2, 5, 10, 20, 50, 100, 200]\n# N <= 10^5\nCOUNT = count(COINS, int(1e5))\n\
    T = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(COUNT[N])",
  comments: '3', difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '1307',
  name: Coin Sums, num: '31', path: 31-Coin-Sums, runtime: '20'}
'310': {difficulty: '40', name: Nim Square}
'311': {difficulty: '70', name: Biclinic Integral Quadrilaterals}
'312': {difficulty: '50', name: "Cyclic paths on Sierpi\u0144ski graphs"}
'313': {difficulty: '30', name: Sliding game}
'314': {difficulty: '80', name: The Mouse on the Moon}
'315': {difficulty: '20', name: Digital root clocks}
'316': {difficulty: '55', name: Numbers in decimal expansions}
'317': {difficulty: '35', name: Firecracker}
'318': {difficulty: '50', name: 2011 nines}
'319': {difficulty: '90', name: Bounded Sequences}
'32': {code: "from itertools import permutations\n\nN = int(input())\n\n# Get all\
    \ pandigital numbers\nPANDIGITAL = permutations(\"\".join(map(str, range(1, N+1))))\n\
    # Use set to avoid duplicates\nPROD = set()\nfor perm in PANDIGITAL:\n    # Split\
    \ into 3 parts\n    # Make sure end of second part is after beginning\n    # j\
    \ > i\n    for i in range(1, N):\n        for j in range(i+1, N):\n          \
    \  x = \"\".join(perm)\n            # Check if three parts in order are valid\n\
    \            if int(x[:i]) * int(x[i:j]) == int(x[j:]):\n                PROD.add(int(x[j:]))\n\
    print(sum(PROD))", comments: '6', difficulty: '5', empty: '2', hrdifficulty: Easy,
  memory: '925', name: Pandigital Products, num: '32', path: 32-Pandigital-Products,
  runtime: '1299'}
'320': {difficulty: '50', name: Factorials divisible by a huge integer}
'321': {difficulty: '30', name: Swapping Counters}
'322': {difficulty: '70', name: Binomial coefficients divisible by 10}
'323': {difficulty: '20', name: Bitwise-OR operations on random integers}
'324': {difficulty: '50', name: Building a tower}
'325': {difficulty: '80', name: Stone Game II}
'326': {difficulty: '55', name: Modulo Summations}
'327': {difficulty: '40', name: Rooms of Doom}
'328': {difficulty: '95', name: Lowest-cost Search}
'329': {difficulty: '25', name: Prime Frog}
'33': {difficulty: '5', hrdifficulty: Hard, name: Digit cancelling fractions, num: '33'}
'330': {difficulty: '70', name: Euler's Number}
'331': {difficulty: '100', name: Cross flips}
'332': {difficulty: '50', name: Spherical triangles}
'333': {difficulty: '35', name: Special partitions}
'334': {difficulty: '65', name: Spilling the beans}
'335': {difficulty: '65', name: Gathering the beans}
'336': {difficulty: '25', name: Maximix Arrangements}
'337': {difficulty: '70', name: Totient Stairstep Sequences}
'338': {difficulty: '95', name: Cutting Rectangular Grid Paper}
'339': {difficulty: '70', name: Peredur fab Efrawg}
'34': {code: "from itertools import combinations_with_replacement\nfrom collections\
    \ import Counter\nfrom math import factorial\n\nDIGITS = {}\n# Correspondence\
    \ from n! -> n\n# Precompute these to save time\nfor n in range(10):\n    DIGITS[n]\
    \ = factorial(n)\n\nans = 0\n# Upper bound of 7 digits\nfor k in range(2, 8):\n\
    \    # Choose k elements from {0,...,9} with replacement\n    for candidate in\
    \ combinations_with_replacement(DIGITS, k):\n        # Get multiset of candidate\
    \ digits\n        digits_used = Counter(map(str, candidate))\n        # Calculate\
    \ candidate factorial sum\n        S = sum([factorial(x) for x in candidate])\n\
    \        # Get multiset of digits in ^\n        # Are these digit multisets the\
    \ same?\n        factorials_used = Counter(str(S))\n        if digits_used ==\
    \ factorials_used:\n            ans += S\nprint(ans)", comments: '8', difficulty: '5',
  empty: '2', hrdifficulty: Easy, memory: '940', name: Digit Factorials, num: '34',
  path: 34-Digit-Factorials, runtime: '20'}
'340': {difficulty: '30', name: Crazy Function}
'341': {difficulty: '45', name: Golomb's self-describing sequence}
'342': {difficulty: '50', name: The totient of a square is a cube}
'343': {difficulty: '35', name: Fractional Sequences}
'344': {difficulty: '100', name: Silver dollar game}
'345': {difficulty: '15', name: Matrix Sum}
'346': {difficulty: '15', name: Strong Repunits}
'347': {difficulty: '15', name: Largest integer divisible by two primes}
'348': {difficulty: '25', name: Sum of a square and a cube}
'349': {difficulty: '35', name: Langton's ant}
'35': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes =\
    \ []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if\
    \ sieve[p]:\n            primes.append(p)\n            # Cross out all multiples\
    \ of p\n            for i in range(p * p, n + 1, p):\n                sieve[i]\
    \ = False\n    return primes\n\n\ndef rotations(x):\n    \"\"\"Find all rotations\
    \ of integer x\"\"\"\n    x = str(x)\n    out = []\n    for i in range(len(x)):\n\
    \        # Move last char in x to front\n        x = x[-1] + x[:-1]\n        out.append(int(x))\n\
    \    return out\n\n\nN = int(input())\nP = primes(int(1e6))\nCIRCULAR = set()\n\
    # Make sure we don't exceed upper bound\nfor x in [p for p in P if p < N]:\n \
    \   # Exclude primes with even digits or 5; they can't be circular\n    # Except\
    \ when x = 2 or x = 5; include those, because they are circular\n    if len(str(x))\
    \ == 1 or not any([d in str(x) for d in \"024568\"]):\n        # Avoid duplicates\n\
    \        if x not in CIRCULAR:\n            ROT = rotations(x)\n            #\
    \ Make sure all of the rotations are prime\n            if all([rot in P for rot\
    \ in ROT]):\n                for rot in ROT:\n                    # Add the rotations\
    \ that are less than N\n                    if rot < N:\n                    \
    \    CIRCULAR.add(rot)\nprint(sum(CIRCULAR))", comments: '8', difficulty: '5',
  empty: '4', hrdifficulty: Easy, memory: '2018', name: Circular Primes, num: '35',
  path: 35-Circular-Primes, runtime: '384'}
'350': {difficulty: '60', name: Constraining the least greatest and the greatest least}
'351': {difficulty: '25', name: Hexagonal orchards}
'352': {difficulty: '55', name: Blood tests}
'353': {difficulty: '50', name: Risky moon}
'354': {difficulty: '65', name: Distances in a bee's honeycomb}
'355': {difficulty: '70', name: Maximal coprime subset}
'356': {difficulty: '60', name: Largest roots of cubic polynomials}
'357': {difficulty: '10', name: Prime generating integers}
'358': {difficulty: '25', name: Cyclic numbers}
'359': {difficulty: '25', name: Hilbert's New Hotel}
'36': {code: "from math import log\n\n\ndef base(n, b):\n    \"\"\"Write (base 10)\
    \ integer n in base b\"\"\"\n    out = \"\"\n    # The maximal place of the first\
    \ digit\n    max_exponent = int(log(n, b))\n    # Starting from the rightmost\
    \ place ^\n    for exp in range(max_exponent, -1, -1):\n        # See how many\
    \ times b**exp goes into n\n        # Subtract it off and keep going\n       \
    \ out += str(n // b**exp)\n        n %= b**exp\n    return out\n\n\ndef pals(n,\
    \ m):\n    \"\"\"Palindromes with <= n digits < m\"\"\"\n    # Initialize with\
    \ one digit palindromes\n    # Note: 0 is not natural in this problem\n    PALS\
    \ = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    # Get all numbers with at most n/2 digits\n\
    \    first_half = list(map(str, range(1, 10**(n//2 + 1))))\n    # This will be\
    \ the 'middle of the sandwich'\n    mid = \"0123456789\"\n    # Odd-length palindromes\n\
    \    # Add the first half, sandwich in the middle, reverse the first half\n  \
    \  PALS += [first_half[i] + x + first_half[i][::-1]\n             for x in mid\
    \ for i in range(len(first_half))]\n    # Even length palindromes\n    # Same\
    \ as above, but without middle\n    PALS += [x + x[::-1] for x in first_half]\n\
    \    return [int(x) for x in PALS if int(x) < m]\n\n\nN, K = map(int, input().split())\n\
    # 10-palindromes with as many digits as N less than N\nP = pals(int(log(N, 10)),\
    \ N)\n# Check if 10-palindrome is also k-palindromic\nprint(sum([x for x in P\
    \ if base(x, K) == base(x, K)[::-1]]))", comments: '14', difficulty: '5', empty: '6',
  hrdifficulty: Easy, memory: '998', name: Double Base Palindromes, num: '36', path: 36-Double-Base-Palindromes,
  runtime: '11'}
'360': {difficulty: '50', name: Scary Sphere}
'361': {difficulty: '90', name: Subsequence of Thue-Morse sequence}
'362': {difficulty: '70', name: Squarefree factors}
'363': {difficulty: '35', name: "B\xE9zier Curves"}
'364': {difficulty: '50', name: Comfortable distance}
'365': {difficulty: '40', name: A huge binomial coefficient}
'366': {difficulty: '40', name: Stone Game III}
'367': {difficulty: '55', name: Bozo sort}
'368': {difficulty: '45', name: A Kempner-like series}
'369': {difficulty: '60', name: Badugi}
'37': {code: "def truncatable_primes(n):\n    \"\"\"Find truncatable prims < n\"\"\
    \"\n    S = 0\n    sieve = [True] * (n + 1)\n    sieve[1] = False\n    for p in\
    \ range(2, n + 1):\n        if sieve[p]:\n            # When a prime is found,\
    \ mark all its multiples\n            for i in range(p * p, n + 1, p):\n     \
    \           sieve[i] = False\n            # Make sure it's truncatable (2,3,5,7\
    \ are not)\n            if p > 10:\n                # Right truncations\n    \
    \            # Chop off rightmost digit as long as truncation is prime\n     \
    \           right = p\n                while right > 0 and sieve[right]:\n   \
    \                 right //= 10\n                # Left truncations\n         \
    \       left = p\n                # Get leftmost digit\n                digit\
    \ = 1\n                while 10*digit <= left:\n                    digit *= 10\n\
    \                # Chop off leftmost dig until truncation is not prime\n     \
    \           while left > 0 and sieve[left]:\n                    left %= digit\n\
    \                    digit //= 10\n                # Is nothing left after right\
    \ and left truncations?\n                # Incomplete truncation -> non-truncatable\
    \ prime\n                if left == 0 and right == 0:\n                    S +=\
    \ p\n    return S\n\n\nN = int(input())\nprint(truncatable_primes(N))", comments: '9',
  difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '1700', name: Truncatable
    Primes, num: '37', path: 37-Truncatable-Primes, runtime: '29'}
'370': {difficulty: '65', name: Geometric triangles}
'371': {difficulty: '30', name: Licence plates}
'372': {difficulty: '60', name: Pencils of rays}
'373': {difficulty: '75', name: Circumscribed Circles}
'374': {difficulty: '40', name: Maximum Integer Partition Product}
'375': {difficulty: '40', name: Minimum of subsequences}
'376': {difficulty: '70', name: Nontransitive sets of dice}
'377': {difficulty: '45', name: 'Sum of digits, experience 13'}
'378': {difficulty: '35', name: Triangle Triples}
'379': {difficulty: '70', name: Least common multiple count}
'38': {difficulty: '5', hrdifficulty: Easy, name: Pandigital multiples, num: '38'}
'380': {difficulty: '60', name: Amazing Mazes!}
'381': {difficulty: '15', name: (prime-k) factorial}
'382': {difficulty: '60', name: Generating polygons}
'383': {difficulty: '50', name: Divisibility comparison between factorials}
'384': {difficulty: '65', name: Rudin-Shapiro sequence}
'385': {difficulty: '70', name: Ellipses inside triangles}
'386': {difficulty: '40', name: Maximum length of an antichain}
'387': {difficulty: '10', name: Harshad Numbers}
'388': {difficulty: '50', name: Distinct Lines}
'389': {difficulty: '30', name: Platonic Dice}
'39': {code: "from math import sqrt\n\n\ndef gcd(a, b):\n    \"\"\"Euclid's algorithm\"\
    \"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\ndef bs(arr, l,\
    \ r, x):\n    \"\"\"Binary Search arr from index l to r for x\"\"\"\n    while\
    \ l <= r:\n        mid = l + (r - l)//2\n        if arr[mid] == x:\n         \
    \   return arr[mid]\n        elif arr[mid] < x:\n            l = mid + 1\n   \
    \     else:\n            r = mid - 1\n    return arr[r]\n\n\nMAX = int(5e6)\n\
    maxm = int(sqrt(MAX//2))\n\n# pythag[p] = no. of sols for perimeter p\npythag\
    \ = [0] * (MAX + 1)\n# Don't need to search m = 0 or n = 0\n# ^ Isoceles right\
    \ triangle with hypotenuse = k*sqrt(2)\nfor m in range(1, maxm+1):\n    # Make\
    \ sure m > n\n    for n in range(1, m):\n        P = 2*m*(m+n)\n        # Check\
    \ three conditions for primitive pythag trip\n        if P <= MAX and (m+n) %\
    \ 2 == 1 and gcd(m, n) == 1:\n            # For each multiple of the PPT, count\
    \ one more sol\n            for k in range(1, MAX//P+1):\n                pythag[k*P]\
    \ += 1\n\n# Compile indices of strictly right maximal vals of pythag\n# Initialize\
    \ with placeholder for comparisons\nfreq = [0]\nfor i, x in enumerate(pythag):\n\
    \    # Only store if stricly greater than max val so far\n    # This makes sure\
    \ the minimal answer is stored\n    if x > pythag[freq[-1]]:\n        freq.append(i)\n\
    # Delete placeholder\ndel freq[0]\n\nT = int(input())\nfor _ in range(T):\n  \
    \  N = int(input())\n    print(bs(freq, 0, len(freq)-1, N))", comments: '11',
  difficulty: '5', empty: '9', hrdifficulty: Easy, memory: '4802', name: Integer Right
    Triangles, num: '39', path: 39-Integer-Right-Triangles, runtime: '250'}
'390': {difficulty: '60', name: Triangles with non rational sides and integral area}
'391': {difficulty: '75', name: Hopping Game}
'392': {difficulty: '35', name: Enmeshed unit circle}
'393': {difficulty: '50', name: Migrating ants}
'394': {difficulty: '55', name: Eating pie}
'395': {difficulty: '40', name: Pythagorean tree}
'396': {difficulty: '40', name: Weak Goodstein sequence}
'397': {difficulty: '70', name: Triangle on parabola}
'398': {difficulty: '55', name: Cutting rope}
'399': {difficulty: '45', name: Squarefree Fibonacci Numbers}
'4': {code: "def bs(arr, l, r, x):\n    \"\"\"Binary Search arr from index l to r\
    \ for x\"\"\"\n    while l <= r:\n        mid = l + (r - l)//2\n        # Is N\
    \ in the array?\n        if arr[mid] == x:\n            # The answer must be less\
    \ than N\n            return arr[mid-1]\n        elif arr[mid] < x:\n        \
    \    l = mid + 1\n        else:\n            r = mid - 1\n    return arr[r]\n\n\
    \npals = set()\nfor i in range(100, 1000):\n    for j in range(100, 1000):\n \
    \       # Test if palindrome\n        if str(i*j) == str(i*j)[::-1]:\n       \
    \     pals.add(i*j)\npals = sorted(list(pals))\n\nT = int(input())\nfor _ in range(T):\n\
    \    N = int(input())\n    ans = bs(pals, 0, len(pals)-1, N)\n    print(ans)",
  comments: '3', difficulty: '5', empty: '3', hrdifficulty: Medium, memory: '925',
  name: Largest Palindrome Product, num: '4', path: 4-Largest-Palindrome-Product,
  runtime: '49'}
'40': {code: "MAX = 10**18\n\n\ndef loc(dig):\n    \"\"\"Find block that dig is part\
    \ of\n    and its position in the block\"\"\"\n    # block in which dig resides\n\
    \    block = 1\n    # no. of integers in block-th block\n    fact = 9\n    # fact\
    \ * block represents the length of the block-th block\n    # If what's left of\
    \ dig is less than fact*block,\n    # then dig is partway through 'block'; we've\
    \ found the right block\n    # Make sure block is not too big, based on input\n\
    \    while dig - fact*block > 0 and fact*block < 9*MAX:\n        # subtract away\
    \ the length of the currrent block\n        dig -= fact*block\n        # Move\
    \ to the next block\n        block += 1\n        # The next block contains ten\
    \ times more numbers\n        fact *= 10\n    # Subtract 1 to zero-index position\
    \ of dig in block\n    return dig-1, block\n\n\ndef digit(n):\n    \"\"\"n-th\
    \ digit of Champernowne's constant\"\"\"\n    pos, block = loc(n)\n    # First\
    \ num in block is 10**(block-1)\n    # pos//block nums precede the number that\
    \ the n-th digit is part of\n    # So the number dig is part of is 10**(block-1)\
    \ + pos//block\n    # dig is the pos%block-th digit in its number\n    dig = int(str(10**(block-1)+pos//block)[pos\
    \ % block])\n    return dig\n\n\ndef dig_prod(arr):\n    \"\"\"Product of i-th\
    \ digits of Champ. constant,\n    where i are the elements of arr\"\"\"\n    out\
    \ = 1\n    for x in arr:\n        out *= digit(x)\n    return out\n\n\nT = int(input())\n\
    for _ in range(T):\n    D = map(int, input().split())\n    print(dig_prod(D))",
  comments: '14', difficulty: '5', empty: '8', hrdifficulty: Medium, memory: '920',
  name: Champernowne's Constant, num: '40', path: 40-Champernownes-Constant, runtime: '5'}
'400': {difficulty: '55', name: Fibonacci tree game}
'401': {difficulty: '25', name: Sum of squares of divisors}
'402': {difficulty: '55', name: Integer-valued polynomials}
'403': {difficulty: '55', name: Lattice points enclosed by parabola and line}
'404': {difficulty: '60', name: Crisscross Ellipses}
'405': {difficulty: '40', name: A rectangular tiling}
'406': {difficulty: '50', name: Guessing Game}
'407': {difficulty: '20', name: Idempotents}
'408': {difficulty: '50', name: Admissible paths through a grid}
'409': {difficulty: '55', name: Nim Extreme}
'41': {code: "from itertools import permutations\nfrom math import sqrt\n\n\ndef bs(arr,\
    \ l, r, x):\n    \"\"\"Binary Search arr from index l to r for x\"\"\"\n    while\
    \ l <= r:\n        mid = l + (r - l)//2\n        if arr[mid] == x:\n         \
    \   return arr[mid]\n        elif arr[mid] < x:\n            l = mid + 1\n   \
    \     else:\n            r = mid - 1\n    return arr[r]\n\n\ndef primes(n):\n\
    \    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes = []\n    sieve = [True] *\
    \ (n + 1)\n    for p in range(2, n + 1):\n        if sieve[p]:\n            primes.append(p)\n\
    \            # Cross out all multiples of p\n            for i in range(p * p,\
    \ n + 1, p):\n                sieve[i] = False\n    return primes\n\n\ndef pandigital(n):\n\
    \    \"\"\"Find all n-digit pandigital numbers\"\"\"\n    pan = \"123456789\"\n\
    \    # Permute first n characters of pan\n    out = permutations(pan[:n])\n  \
    \  # Join each tuple into a str, then an int\n    return [int(\"\".join(x)) for\
    \ x in out]\n\n\n# We need primes up to int(sqrt(10**7 - 1)) = 3162\nP = primes(3162)\n\
    # All other pandigitals are divisible by 3\nPAN = pandigital(4) + pandigital(7)\n\
    PAN_PRIME = []\nfor pan in PAN:\n    # Test if pan is in our list of primes\n\
    \    # Or it is not divisible by any prime <= sqrt(pan)\n    if pan in P or all([pan\
    \ % p != 0 for p in P if p <= int(sqrt(pan))]):\n        PAN_PRIME.append(pan)\n\
    \nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(bs(PAN_PRIME,\
    \ 0, len(PAN_PRIME)-1, N))", comments: '7', difficulty: '5', empty: '9', hrdifficulty: Easy,
  memory: '958', name: Pandigital Prime, num: '41', path: 41-Pandigital-Prime, runtime: '62'}
'410': {difficulty: '70', name: Circle and tangent line}
'411': {difficulty: '45', name: Uphill paths}
'412': {difficulty: '50', name: Gnomon numbering}
'413': {difficulty: '75', name: One-child Numbers}
'414': {difficulty: '60', name: Kaprekar constant}
'415': {difficulty: '100', name: Titanic sets}
'416': {difficulty: '80', name: A frog's trip}
'417': {difficulty: '35', name: Reciprocal cycles II}
'418': {difficulty: '40', name: Factorisation triples}
'419': {difficulty: '50', name: Look and say sequence}
'42': {code: "def is_triangular(n):\n    \"\"\"Implement eq. (2)\"\"\"\n    inv =\
    \ (-1+(1+8*n)**0.5)/2\n    status = inv == int(inv)\n    if not status:\n    \
    \    inv = -1\n    return inv\n\n\ndef score(s):\n    \"\"\"Get word score of\
    \ string s\"\"\"\n    # For each letter, find the position of the letter in ALPH\n\
    \    # Add one because ALPH is 0-indexed\n    ALPH = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    return sum([ALPH.index(x) + 1 for x in s])\n\n\nwith open(\"words.txt\"\
    , \"r\") as f:\n    # Remove spaces and quotation marks\n    words = f.readline().split(\"\
    ,\")\n    words = [x.replace('\"', \"\") for x in words]\n\ncount = 0\nfor x in\
    \ words:\n    # Check if word score is triangular\n    if is_triangular(score(x))\
    \ != -1:\n        count += 1\nprint(count)", comments: '4', difficulty: '5', empty: '5',
  hrdifficulty: Easy, memory: '8792', name: Coded Triangle Numbers, num: '42', path: 42-Coded-Triangle-Numbers,
  runtime: '30'}
'420': {difficulty: '60', name: 2x2 positive integer matrix}
'421': {difficulty: '50', name: Prime factors of n15+1}
'422': {difficulty: '75', name: Sequence of points on a hyperbola}
'423': {difficulty: '45', name: Consecutive die throws}
'424': {difficulty: '60', name: Kakuro}
'425': {difficulty: '25', name: Prime connection}
'426': {difficulty: '75', name: Box-ball system}
'427': {difficulty: '95', name: n-sequences}
'428': {difficulty: '90', name: Necklace of circles}
'429': {difficulty: '20', name: Sum of squares of unitary divisors}
'43': {difficulty: '5', hrdifficulty: Easy, name: Sub-string divisibility, num: '43'}
'430': {difficulty: '35', name: Range flips}
'431': {difficulty: '40', name: Square Space Silo}
'432': {difficulty: '70', name: Totient sum}
'433': {difficulty: '65', name: Steps in Euclid's algorithm}
'434': {difficulty: '75', name: Rigid graphs}
'435': {difficulty: '30', name: Polynomials of Fibonacci numbers}
'436': {difficulty: '55', name: Unfair wager}
'437': {difficulty: '35', name: Fibonacci primitive roots}
'438': {difficulty: '95', name: Integer part of polynomial equation's solutions}
'439': {difficulty: '100', name: Sum of sum of divisors}
'44': {code: "def pent(n):\n    \"\"\"n-th pentagonal number\"\"\"\n    return (3*n*n\
    \ - n)//2\n\n\ndef is_pent(n):\n    \"\"\"is n a pentagonal number?\"\"\"\n  \
    \  if n <= 0:\n        return False\n    # Implement eq. (3)\n    inv = (1+(24*n+1)**0.5)/6\n\
    \    return inv == int(inv)\n\n\nN, K = map(int, input().split())\nout = set()\n\
    \n# Try everything up to max\nfor n in range(K+1, N):\n    a, b = pent(n), pent(n-K)\n\
    \    # Do we have a pent no.?\n    if is_pent(a-b) or is_pent(a+b):\n        out.add(a)\n\
    for x in sorted(out):\n    print(x)", comments: '3', difficulty: '5', empty: '5',
  hrdifficulty: Easy, memory: '8716', name: Pentagon Numbers, num: '44', path: 44-Pentagon-Numbers,
  runtime: '2128'}
'440': {difficulty: '60', name: GCD and Tiling}
'441': {difficulty: '65', name: The inverse summation of coprime couples}
'442': {difficulty: '60', name: Eleven-free integers}
'443': {difficulty: '30', name: GCD sequence}
'444': {difficulty: '60', name: The Roundtable Lottery}
'445': {difficulty: '50', name: Retractions A}
'446': {difficulty: '60', name: Retractions B}
'447': {difficulty: '95', name: Retractions C}
'448': {difficulty: '80', name: Average least common multiple}
'449': {difficulty: '35', name: Chocolate covered candy}
'45': {difficulty: '5', hrdifficulty: Easy, name: 'Triangular, pentagonal, and hexagonal',
  num: '45'}
'450': {difficulty: '100', name: Hypocycloid and Lattice points}
'451': {difficulty: '30', name: Modular inverses}
'452': {difficulty: '45', name: Long Products}
'453': {difficulty: '95', name: Lattice Quadrilaterals}
'454': {difficulty: '50', name: Diophantine reciprocals III}
'455': {difficulty: '40', name: Powers With Trailing Digits}
'456': {difficulty: '50', name: Triangles containing the origin II}
'457': {difficulty: '35', name: A polynomial modulo the square of a prime}
'458': {difficulty: '30', name: Permutations of Project}
'459': {difficulty: '100', name: Flipping game}
'46': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes =\
    \ []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if\
    \ sieve[p]:\n            primes.append(p)\n            # Cross out all multiples\
    \ of p\n            for i in range(p * p, n + 1, p):\n                sieve[i]\
    \ = False\n                return primes\n\n\n# MAX input is 5*10^5\nP = primes(int(5e5))\n\
    \n\ndef ways(n):\n    \"\"\"No. of ways n can be written as p + 2k^2\n    for\
    \ prime p and integer k\"\"\"\n    # Implement eq. (1)\n    def cand(p): return\
    \ ((n-p)/2)**0.5\n    # Get no. of primes less than n which produce a valid candidate\n\
    \    return len(set(p for p in P if p < n and cand(p) == int(cand(p))))\n\n\n\
    T = int(input())\nfor _ in range(T):\n    N = int(input())\n    print(ways(N))",
  comments: '4', difficulty: '5', empty: '6', hrdifficulty: Easy, memory: '1295',
  name: Goldbach's Other Conjecture, num: '46', path: 46-Goldbachs-Other-Conjecture,
  runtime: '9'}
'460': {difficulty: '55', name: An ant on the move}
'461': {difficulty: '30', name: Almost Pi}
'462': {difficulty: '60', name: Permutation of 3-smooth numbers}
'463': {difficulty: '35', name: A weird recurrence relation}
'464': {difficulty: '60', name: "M\xF6bius function and intervals"}
'465': {difficulty: '85', name: Polar polygons}
'466': {difficulty: '65', name: Distinct terms in a multiplication table}
'467': {difficulty: '50', name: Superinteger}
'468': {difficulty: '70', name: Smooth divisors of binomial coefficients}
'469': {difficulty: '40', name: Empty chairs}
'47': {code: "def omega(n):\n    \"\"\"No. of distinct prime factors of all m < n\"\
    \"\"\n    sieve = [0] * (n + 1)\n    for p in range(2, n + 1):\n        if sieve[p]\
    \ == 0:\n            for i in range(p, n + 1, p):\n                sieve[i] +=\
    \ 1\n    return sieve\n\n\ndef consecutive(n, k):\n    \"\"\"Find all consec.\
    \ sets of size k where\n    each element has exactly k distinct prime factors\"\
    \"\"\n    FACTORS = omega(n+k-1)\n    out = []\n    for i in range(n+1):\n   \
    \     if all([FACTORS[i+j] == k for j in range(k)]):\n            out.append(i)\n\
    \    return out\n\n\nN, K = map(int, input().split())\nfor x in consecutive(N,\
    \ K):\n    print(x)", comments: '0', difficulty: '5', empty: '4', hrdifficulty: Easy,
  memory: '1021', name: Distinct Primes Factors, num: '47', path: 47-Distinct-Primes-Factors,
  runtime: '17'}
'470': {difficulty: '65', name: Super Ramvok}
'471': {difficulty: '75', name: Triangle inscribed in ellipse}
'472': {difficulty: '60', name: Comfortable Distance II}
'473': {difficulty: '35', name: Phigital number base}
'474': {difficulty: '50', name: Last digits of divisors}
'475': {difficulty: '50', name: Music festival}
'476': {difficulty: '45', name: Circle Packing II}
'477': {difficulty: '65', name: Number Sequence Game}
'478': {difficulty: '100', name: Mixtures}
'479': {difficulty: '25', name: Roots on the Rise}
'48': {code: "N = int(input())\nM = 10**10\nS = 0\nfor n in range(1, N+1):\n    #\
    \ Take powers mod 10^10\n    # Mod 10^10 at the end\n    S = (S + pow(n, n, M))\
    \ % M\nprint(S)", comments: '2', difficulty: '5', empty: '0', hrdifficulty: Easy,
  memory: '923', name: Self Powers, num: '48', path: 48-Self-Powers, runtime: '3'}
'480': {difficulty: '45', name: The Last Question}
'481': {difficulty: '70', name: Chef Showdown}
'482': {difficulty: '85', name: The incenter of a triangle}
'483': {difficulty: '100', name: Repeated permutation}
'484': {difficulty: '100', name: Arithmetic Derivative}
'485': {difficulty: '30', name: Maximum number of divisors}
'486': {difficulty: '70', name: Palindrome-containing strings}
'487': {difficulty: '40', name: Sums of power sums}
'488': {difficulty: '80', name: Unbalanced Nim}
'489': {difficulty: '100', name: Common factors between two sequences}
'49': {difficulty: '5', hrdifficulty: Hard, name: Prime permutations, num: '49'}
'490': {difficulty: '90', name: Jumping frog}
'491': {difficulty: '20', name: Double pandigital number divisible by 11}
'492': {difficulty: '60', name: Exploding sequence}
'493': {difficulty: '10', name: Under The Rainbow}
'494': {difficulty: '100', name: Collatz prefix families}
'495': {difficulty: '100', name: Writing n as the product of k distinct positive integers}
'496': {difficulty: '50', name: Incenter and circumcenter of triangle}
'497': {difficulty: '40', name: Drunken Tower of Hanoi}
'498': {difficulty: '40', name: Remainder of polynomial division}
'499': {difficulty: '100', name: St. Petersburg Lottery}
'5': {code: "from math import log\n\n\ndef primes(n):\n    \"\"\"Sieve of Eratosthenes\"\
    \"\"\n    primes = []\n    sieve = [True] * (n + 1)\n    for p in range(2, n +\
    \ 1):\n        if sieve[p]:\n            primes.append(p)\n            # Cross\
    \ out all multiples of p\n            for i in range(p * p, n + 1, p):\n     \
    \           sieve[i] = False\n    return primes\n\n\ndef min_mult(n):\n    \"\"\
    \"Implement eq. (1)\"\"\"\n    P = primes(n)\n    ans = 1\n    for p in P:\n \
    \       ans *= p**int(log(n, p))\n    return ans\n\n\nT = int(input())\nfor _\
    \ in range(T):\n    N = int(input())\n    print(min_mult(N))", comments: '1',
  difficulty: '5', empty: '6', hrdifficulty: Medium, memory: '917', name: Smallest
    Multiple, num: '5', path: 5-Smallest-Multiple, runtime: '3'}
'50': {difficulty: '5', hrdifficulty: Hard, name: Consecutive prime sum, num: '50'}
'500': {difficulty: '15', name: Problem 500!!!}
'501': {difficulty: '40', name: Eight Divisors}
'502': {difficulty: '100', name: Counting Castles}
'503': {difficulty: '60', name: Compromise or persist}
'504': {difficulty: '15', name: Square on the Inside}
'505': {difficulty: '90', name: Bidirectional Recurrence}
'506': {difficulty: '30', name: Clock sequence}
'507': {difficulty: '90', name: Shortest Lattice Vector}
'508': {difficulty: '85', name: Integers in base i-1}
'509': {difficulty: '40', name: Divisor Nim}
'51': {difficulty: '15', hrdifficulty: Advanced, name: Prime digit replacements, num: '51'}
'510': {difficulty: '30', name: Tangent Circles}
'511': {difficulty: '55', name: Sequences with nice divisibility properties}
'512': {difficulty: '25', name: Sums of totients of powers}
'513': {difficulty: '60', name: Integral median}
'514': {difficulty: '90', name: Geoboard Shapes}
'515': {difficulty: '40', name: Dissonant Numbers}
'516': {difficulty: '20', name: 5-smooth totients}
'517': {difficulty: '45', name: A real recursion}
'518': {difficulty: '20', name: Prime triples and geometric sequences}
'519': {difficulty: '50', name: Tricolored Coin Fountains}
'52': {code: "def is_perm(arr):\n    \"\"\"Does arr consist of permutations of some\
    \ string\"\"\"\n    return all([sorted(arr[0]) == sorted(x) for x in arr])\n\n\
    \nN, K = map(int, input().split())\n# We are given N >= 125874\nfor i in range(125874,\
    \ N+1):\n    # First check that all digits are unique\n    # Then check that Ki\
    \ is not too long\n    if len(str(i)) == len(set(str(i))) and len(str(i*K)) ==\
    \ len(str(i)):\n        # Generate multiples\n        S = [str(i*j) for j in range(1,\
    \ K+1)]\n        # Check that all multiples are permutations\n        if is_perm(S):\n\
    \            print(\" \".join(S))", comments: '5', difficulty: '5', empty: '2',
  hrdifficulty: Easy, memory: '942', name: Permuted Multiples, num: '52', path: 52-Permuted-Multiples,
  runtime: '8'}
'520': {difficulty: '45', name: Simbers}
'521': {difficulty: '45', name: Smallest prime factor}
'522': {difficulty: '85', name: Hilbert's Blackout}
'523': {difficulty: '30', name: First Sort I}
'524': {difficulty: '70', name: First Sort II}
'525': {difficulty: '45', name: Rolling Ellipse}
'526': {difficulty: '60', name: Largest prime factors of consecutive numbers}
'527': {difficulty: '30', name: Randomized Binary Search}
'528': {difficulty: '55', name: Constrained Sums}
'529': {difficulty: '80', name: 10-substrings}
'53': {code: "def choose_max(n, k):\n    \"\"\"No. of entries in n-th row of Pascal's\
    \ triangle\n    less than k\"\"\"\n    # The current binomial coefficient\n  \
    \  curr = 1\n    # Go up to the central coefficient\n    for i in range(n//2+(n+1)\
    \ % 2):\n        if curr > k:\n            # Count all the entries from i to n-i\n\
    \            return n + 1 - 2*i\n        # Recurrence relation for next coeff\n\
    \        curr *= n - i\n        curr //= i + 1\n    # No entries > K were found\n\
    \    return 0\n\n\nN, K = map(int, input().split())\n# Add up all the rows up\
    \ to N\nprint(sum([choose_max(n, K) for n in range(1, N+1)]))", comments: '6',
  difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '942', name: Combinatoric
    Selections, num: '53', path: 53-Combinatoric-Selections, runtime: '5'}
'530': {difficulty: '55', name: GCD of Divisors}
'531': {difficulty: '25', name: Chinese leftovers}
'532': {difficulty: '55', name: Nanobots on Geodesics}
'533': {difficulty: '50', name: Minimum values of the Carmichael function}
'534': {difficulty: '55', name: Weak Queens}
'535': {difficulty: '55', name: Fractal Sequence}
'536': {difficulty: '55', name: Modulo power identity}
'537': {difficulty: '35', name: Counting tuples}
'538': {difficulty: '40', name: Maximum quadrilaterals}
'539': {difficulty: '30', name: Odd elimination}
'54': {difficulty: '10', hrdifficulty: Easy, name: Poker hands, num: '54'}
'540': {difficulty: '30', name: Counting primitive Pythagorean triples}
'541': {difficulty: '90', name: Divisibility of Harmonic Number Denominators}
'542': {difficulty: '65', name: Geometric Progression with Maximum Sum}
'543': {difficulty: '30', name: Prime-Sum Numbers}
'544': {difficulty: '85', name: Chromatic Conundrum}
'545': {difficulty: '35', name: Faulhaber's Formulas}
'546': {difficulty: '80', name: The Floor's Revenge}
'547': {difficulty: '70', name: Distance of random points within hollow square laminae}
'548': {difficulty: '35', name: Gozinta Chains}
'549': {difficulty: '10', name: Divisibility of factorials}
'55': {code: "def is_pal(n):\n    \"\"\"Is n a palindrome?\"\"\"\n    return str(n)\
    \ == str(n)[::-1]\n\n\ndef pal_result(n):\n    \"\"\"What number does n converge\
    \ to?\"\"\"\n    # palindromes covnerge to themselves\n    if is_pal(n):\n   \
    \     return n\n    i = 0\n    # Iterate at most 60 times\n    while i < 60:\n\
    \        i += 1\n        n += int(str(n)[::-1])\n        # Return the palindrome,\
    \ if found\n        if is_pal(n):\n            return n\n    # Return 0 if we\
    \ use 60 iterations\n    return 0\n\n\nN = int(input())\nfreq = {}\n\nfor n in\
    \ range(1, N+1):\n    res = pal_result(n)\n    if res not in freq:\n        freq[res]\
    \ = 0\n    # For each k that converges to n,\n    # add 1 to the entry corresponding\
    \ to n\n    freq[res] += 1\n# Remove all suspected Lychrel numbers from count\n\
    freq[0] = 0\n\n# Get (pal, count) pairs\n# Sort pairs by count in decreasing order\n\
    # Get first pair\npals = [(x, freq[x]) for x in freq]\npals = sorted(pals, key=lambda\
    \ t: t[1], reverse=True)[0]\nprint(\"{} {}\".format(pals[0], pals[1]))", comments: '10',
  difficulty: '5', empty: '6', hrdifficulty: Easy, memory: '934', name: Lychrel Numbers,
  num: '55', path: 55-Lychrel-Numbers, runtime: '9'}
'550': {difficulty: '55', name: Divisor game}
'551': {difficulty: '50', name: Sum of digits sequence}
'552': {difficulty: '40', name: Chinese leftovers II}
'553': {difficulty: '80', name: Power sets of power sets}
'554': {difficulty: '75', name: Centaurs on a chess board}
'555': {difficulty: '30', name: McCarthy 91 function}
'556': {difficulty: '80', name: Squarefree Gaussian Integers}
'557': {difficulty: '55', name: Cutting triangles}
'558': {difficulty: '60', name: Irrational base}
'559': {difficulty: '95', name: Permuted Matrices}
'56': {code: "def dig_sum(n):\n    return sum([int(x) for x in str(n)])\n\n\nN = int(input())\n\
    print(max([dig_sum(a**b) for a in range(1, N) for b in range(1, N)]))", comments: '0',
  difficulty: '5', empty: '2', hrdifficulty: Easy, memory: '944', name: Powerful Digit
    Sum, num: '56', path: 56-Powerful-Digit-Sum, runtime: '21'}
'560': {difficulty: '70', name: Coprime Nim}
'561': {difficulty: '30', name: Divisor Pairs}
'562': {difficulty: '75', name: Maximal perimeter}
'563': {difficulty: '45', name: Robot Welders}
'564': {difficulty: '55', name: Maximal polygons}
'565': {difficulty: '35', name: Divisibility of sum of divisors}
'566': {difficulty: '100', name: Cake Icing Puzzle}
'567': {difficulty: '50', name: Reciprocal games I}
'568': {difficulty: '55', name: Reciprocal games II}
'569': {difficulty: '45', name: Prime Mountain Range}
'57': {code: "def next_convergent(p, q):\n    \"\"\"Implement eq. (2)\"\"\"\n    return\
    \ p+2*q, p+q\n\n\np, q = 1, 1\nN = int(input())\nfor i in range(1, N+1):\n   \
    \ p, q = next_convergent(p, q)\n    # Does num have more digits than den?\n  \
    \  if len(str(p)) > len(str(q)):\n        print(i)", comments: '1', difficulty: '5',
  empty: '2', hrdifficulty: Easy, memory: '918', name: Square Root Convergents, num: '57',
  path: 57-Square-Root-Convergents, runtime: '4'}
'570': {difficulty: '50', name: Snowflakes}
'571': {difficulty: '25', name: Super Pandigital Numbers}
'572': {difficulty: '50', name: Idempotent matrices}
'573': {difficulty: '80', name: Unfair race}
'574': {difficulty: '50', name: Verifying Primes}
'575': {difficulty: '35', name: Wandering Robots}
'576': {difficulty: '55', name: Irrational jumps}
'577': {difficulty: '20', name: Counting hexagons}
'578': {difficulty: '80', name: Integers with decreasing prime powers}
'579': {difficulty: '100', name: Lattice points in lattice cubes}
'58': {code: "def try_composite(a, d, n, s):\n    \"\"\"Helper function for Miller-Rabin\n\
    \    Test if n is definitely composite\"\"\"\n    if pow(a, d, n) == 1:\n    \
    \    return False\n    for i in range(s):\n        if pow(a, 2**i*d, n) == n-1:\n\
    \            return False\n        return True\n\n\nknown_primes = [2, 3]\n\n\n\
    def is_prime(n, precision=16):\n    \"\"\"Miller-Rabin primality test\"\"\"\n\
    \    if n in known_primes or n in (0, 1):\n        return True\n    if any((n\
    \ % p) == 0 for p in known_primes):\n        return False\n    d, s = n - 1, 0\n\
    \    while not d % 2:\n        d, s = d >> 1, s + 1\n        if n < 1373653:\n\
    \            return not any(try_composite(a, d, n, s) for a in (2, 3))\n     \
    \   if n < 25326001:\n            return not any(try_composite(a, d, n, s) for\
    \ a in (2, 3, 5))\n        if n < 118670087467:\n            if n == 3215031751:\n\
    \                return False\n            return not any(try_composite(a, d,\
    \ n, s) for a in (2, 3, 5, 7))\n        if n < 2152302898747:\n            return\
    \ not any(try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11))\n        if n <\
    \ 3474749660383:\n            return not any(try_composite(a, d, n, s) for a in\
    \ (2, 3, 5, 7, 11, 13))\n        if n < 341550071728321:\n            return not\
    \ any(try_composite(a, d, n, s) for a in (2, 3, 5, 7, 11, 13, 17))\n        return\
    \ not any(try_composite(a, d, n, s) for a in known_primes[:precision])\n\n\nknown_primes\
    \ += [x for x in range(5, 1000, 2) if is_prime(x)]\n\n# Side length of square\n\
    n = 1\n# No. of primes found\np = 0\nN = int(input())\nwhile True:\n    # Go to\
    \ next odd number\n    n += 2\n    # Add all the primes of the form n^2 - i(n-1),\
    \ i in {1,2,3}\n    p += sum([is_prime(x) for x in [n**2 - i*(n-1) for i in range(1,\
    \ 4)]])\n    if 100*p/(2*n - 1) < N:\n        break\nprint(n)", comments: '4',
  difficulty: '5', empty: '7', hrdifficulty: Easy, memory: '944', name: Spiral Primes,
  num: '58', path: 58-Spiral-Primes, runtime: '38'}
'580': {difficulty: '70', name: Squarefree Hilbert numbers}
'581': {difficulty: '30', name: 47-smooth triangular numbers}
'582': {difficulty: '45', name: Nearly isosceles 120 degree triangles}
'583': {difficulty: '45', name: Heron Envelopes}
'584': {difficulty: '95', name: Birthday Problem Revisited}
'585': {difficulty: '100', name: Nested square roots}
'586': {difficulty: '70', name: Binary Quadratic Form}
'587': {difficulty: '20', name: Concave triangle}
'588': {difficulty: '35', name: Quintinomial coefficients}
'589': {difficulty: '90', name: Poohsticks Marathon}
'59': {difficulty: '5', hrdifficulty: Easy, name: XOR decryption, num: '59'}
'590': {difficulty: '60', name: Sets with a given Least Common Multiple}
'591': {difficulty: '95', name: Best Approximations by Quadratic Integers}
'592': {difficulty: '60', name: Factorial trailing digits 2}
'593': {difficulty: '35', name: Fleeting Medians}
'594': {difficulty: '85', name: Rhombus Tilings}
'595': {difficulty: '35', name: Incremental Random Sort}
'596': {difficulty: '50', name: Number of lattice points in a hyperball}
'597': {difficulty: '100', name: Torpids}
'598': {difficulty: '40', name: Split Divisibilities}
'599': {difficulty: '60', name: Distinct Colourings of a Rubik's Cube}
'6': {code: "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    ans =\
    \ abs((3*N**4 + 2*N**3 - 3*N**2 - 2*N)//12)\n    print(ans)", comments: '0', difficulty: '5',
  empty: '0', hrdifficulty: Easy, memory: '918', name: Sum Square Difference, num: '6',
  path: 6-Sum-Square-Difference, runtime: '2'}
'60': {difficulty: '20', hrdifficulty: Hard, name: Prime pair sets, num: '60'}
'600': {difficulty: '35', name: Integer sided equiangular hexagons}
'601': {difficulty: '20', name: Divisibility streaks}
'602': {difficulty: '35', name: Product of Head Counts}
'603': {difficulty: '45', name: Substring sums of prime concatenations}
'604': {difficulty: '40', name: Convex path in square}
'605': {difficulty: '25', name: Pairwise Coin-Tossing Game}
'606': {difficulty: '50', name: Gozinta Chains II}
'607': {difficulty: '20', name: Marsh Crossing}
'608': {difficulty: '80', name: Divisor Sums}
'609': {difficulty: '20', name: "\u03C0 sequences"}
'61': {difficulty: '20', hrdifficulty: Easy, name: Cyclical figurate numbers, num: '61'}
'610': {difficulty: '35', name: Roman Numerals II}
'611': {difficulty: '55', name: Hallway of square steps}
'612': {difficulty: '30', name: Friend numbers}
'613': {difficulty: '20', name: Pythagorean Ant}
'614': {difficulty: '55', name: Special partitions 2}
'615': {difficulty: '35', name: The millionth number with at least one million prime
    factors}
'616': {difficulty: '40', name: Creative numbers}
'617': {difficulty: '35', name: Mirror Power Sequence}
'618': {difficulty: '20', name: Numbers with a given prime factor sum}
'619': {name: Square subsets}
'62': {difficulty: '15', hrdifficulty: Easy, name: Cubic permutations, num: '62'}
'620': {name: Planetary Gears}
'621': {name: Expressing an integer as the sum of triangular numbers}
'622': {name: Riffle Shuffles}
'623': {name: Lambda Count}
'624': {name: Two heads are better than one}
'625': {name: Gcd sum}
'63': {code: "from math import ceil\nN = int(input())\nlo = ceil(10**(1 - 1/N))\n\
    for n in range(lo, 10):\n    print(n**N)", comments: '0', difficulty: '5', empty: '0',
  hrdifficulty: Easy, memory: '938', name: Powerful Digit Counts, num: '63', path: 63-Powerful-Digit-Counts,
  runtime: '3'}
'64': {difficulty: '20', hrdifficulty: Easy, name: Odd period square roots, num: '64'}
'65': {code: "def coeff(n):\n    \"\"\"Implement eq. (7)\"\"\"\n    if n == 0:\n \
    \       return 2\n    elif n % 3 == 2:\n        return 2*(n+1)//3\n    return\
    \ 1\n\n\n# Cache P(n-1) and P(n-2)\nCONV = [1, coeff(0)]\nN = int(input())\nfor\
    \ i in range(2, N+1):\n    next_term = coeff(i-1)*CONV[1] + CONV[0]\n    CONV.append(next_term)\n\
    \    del CONV[0]\n# Take digital sum\nprint(sum([int(x) for x in str(CONV[1])]))",
  comments: '2', difficulty: '15', empty: '2', hrdifficulty: Easy, memory: '930',
  name: Convergents of $e$, num: '65', path: 65-Convergents-of-e, runtime: '6'}
'66': {difficulty: '25', hrdifficulty: Hard, name: Diophantine equation, num: '66'}
'67': {code: "def parents(i, j):\n    \"\"\"Indices of adjacent entries to (i,j) in\
    \ row above\"\"\"\n    out = []\n    if j < i:\n        out.append(j)\n    if\
    \ 0 < j:\n        out.append(j-1)\n    return out\n\n\ndef max_sum(arr):\n   \
    \ \"\"\"Maximal path sum down triangular array\"\"\"\n    # The previous rows\
    \ max_sums\n    parent = []\n    for i, row in enumerate(arr):\n        curr =\
    \ []\n        if i == 0:\n            # Handle the case where there are no parents\n\
    \            curr = [row[0]]\n        else:\n            # Get the higher parent\
    \ sum and add the current entry\n            for j, elem in enumerate(row):\n\
    \                curr.append(elem + max([parent[x] for x in parents(i, j)]))\n\
    \        # We're done with the row\n        # So move it into memory for the next\
    \ row\n        parent = curr\n    return max(parent)\n\n\nT = int(input())\nfor\
    \ _ in range(T):\n    N = int(input())\n    rows = [list(map(int, input().split()))\
    \ for _ in range(N)]\n    ans = max_sum(rows)\n    print(ans)", comments: '5',
  difficulty: '5', empty: '4', hrdifficulty: Medium, memory: '938', name: Maximum
    Path Sum II, num: '67', path: 67-Maximum-Path-Sum-II, runtime: '4'}
'68': {difficulty: '25', hrdifficulty: Hard, name: Magic 5-gon ring, num: '68'}
'69': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes =\
    \ []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if\
    \ sieve[p]:\n            primes.append(p)\n            # Cross out all multiples\
    \ of p\n            for i in range(p * p, n + 1, p):\n                sieve[i]\
    \ = False\n    return primes\n\n\n# Get primes up to 41\nP = primes(41)\n\n\n\
    def max_ratio(n):\n    \"\"\"Maximize k/phi(k), where k < n\"\"\"\n    out = 1\n\
    \    i = 0\n    # Multiply primes until upper bound\n    while out*P[i] < n:\n\
    \        out *= P[i]\n        i += 1\n    return out\n\n\nT = int(input())\nfor\
    \ _ in range(T):\n    N = int(input())\n    print(max_ratio(N))", comments: '3',
  difficulty: '10', empty: '6', hrdifficulty: Easy, memory: '929', name: Totient Maximum,
  num: '69', path: 69-Totient-Maximum, runtime: '5'}
'7': {code: "from math import log\n\n\ndef primes(n):\n    \"\"\"Sieve of Eratosthenes\"\
    \"\"\n    primes = []\n    sieve = [True] * (n + 1)\n    for p in range(2, n +\
    \ 1):\n        if sieve[p]:\n            primes.append(p)\n            # Cross\
    \ out all multiples of p\n            for i in range(p * p, n + 1, p):\n     \
    \           sieve[i] = False\n    return primes\n\n\ndef n_primes(n):\n    \"\"\
    \"Generate more than n primes with eq. (1)\"\"\"\n    upper = int(n*log(n) + n*log(log(n)))\n\
    \    return primes(upper)\n\n\nP = n_primes(10001)\nT = int(input())\nfor _ in\
    \ range(T):\n    N = int(input())\n    print(P[N-1])", comments: '1', difficulty: '5',
  empty: '6', hrdifficulty: Easy, memory: '1026', name: 10001st Prime, num: '7', path: 7-10001-Prime,
  runtime: '4'}
'70': {difficulty: '20', hrdifficulty: Easy, name: Totient permutation, num: '70'}
'71': {code: "def egcd(a, b):\n    \"\"\"Extended Euclidean Algorithm\"\"\"\n    if\
    \ a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a,\
    \ a)\n        return (g, x - (b // a) * y, y)\n\n\ndef inv(a, m):\n    \"\"\"\
    Modular inverse\"\"\"\n    g, x, y = egcd(a, m)\n    if g != 1:\n        return\
    \ None\n    else:\n        return x % m\n\n\nT = int(input())\nfor _ in range(T):\n\
    \    a, b, N = map(int, input().split())\n    k = inv(a, b)\n    # Implement eq.\
    \ (9)\n    den = b*((N-k)//b) + k\n    num = (a*den - 1)//b\n    print(num, den)",
  comments: '1', difficulty: '10', empty: '4', hrdifficulty: Medium, memory: '930',
  name: Ordered Fractions, num: '71', path: 71-Ordered-Fractions, runtime: '4'}
'72': {code: "def phi(n):\n    \"\"\"phi(k) for all k < n\"\"\"\n    PHI = [0] * (n+1)\n\
    \    for p in range(2, n + 1):\n        # If p is prime, set its totient value\n\
    \        # and that of all its multiples\n        if PHI[p] == 0:\n          \
    \  PHI[p] = p-1\n            for i in range(2*p, n + 1, p):\n                #\
    \ Initialize phi(i)\n                if PHI[i] == 0:\n                    PHI[i]\
    \ = i\n                # Use Euler product formula\n                PHI[i] -=\
    \ PHI[i]//p\n    return PHI\n\n\n# Create prefix sum array\nS = []\ncount = 0\n\
    MAX = int(1e6)\nfor n in phi(MAX):\n    count += n\n    S.append(count)\n\nT =\
    \ int(input())\nfor _ in range(T):\n    N = int(input())\n    print(S[N])", comments: '5',
  difficulty: '20', empty: '3', hrdifficulty: Easy, memory: '9571', name: Counting
    Fractions, num: '72', path: 72-Counting-Fractions, runtime: '132'}
'73': {difficulty: '15', hrdifficulty: Easy, name: Counting fractions in a range,
  num: '73'}
'74': {difficulty: '15', hrdifficulty: Easy, name: Digit factorial chains, num: '74'}
'75': {code: "from math import sqrt\n\n\ndef bs(arr, l, r, x):\n    \"\"\"Binary Search\
    \ arr from index l to r for x\"\"\"\n    while l <= r:\n        mid = l + (r -\
    \ l)//2\n        if arr[mid] == x:\n            return mid\n        elif arr[mid]\
    \ < x:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return\
    \ r\n\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n        return\
    \ a\n\n\nMAX = int(5e6)\nmaxm = int(sqrt(MAX//2))\n\n# pythag[p] = no. of sols\
    \ for perimeter p\npythag = [0] * (MAX + 1)\n# Don't need to search m = 0 or n\
    \ = 0\n# ^ Isoceles right triangle with hypotenuse = k*sqrt(2)\nfor m in range(1,\
    \ maxm):\n    # Make sure m > n\n    for n in range(1, m+1):\n        P = 2*m*(m+n)\n\
    \        # Check three conditions for primitive pythag trip\n        if P <= MAX\
    \ and (m+n) % 2 == 1 and gcd(m, n) == 1:\n            # For each multiple of the\
    \ PPT, count one more sol\n            for k in range(1, MAX//P + 1):\n      \
    \          pythag[k*P] += 1\n\n# Find indices of perims with only one sol\nsingular\
    \ = [0]\nfor i, x in enumerate(pythag):\n    if x == 1:\n        singular.append(i)\n\
    \nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    # Binary search\
    \ for answer.\n    print(bs(singular, 0, len(singular)-1, N))", comments: '8',
  difficulty: '25', empty: '9', hrdifficulty: Easy, memory: '6249', name: Singular
    Integer Right Triangles, num: '75', path: 75-Singular-Integer-Right-Triangles,
  runtime: '115'}
'76': {code: "# Report ans mod 10^9 + 7\nP = 1000000007\n# Create dp table\ndp = [0]\
    \ * (1001)\n# There is 1 way to partition nothing\ndp[0] = 1\n# \"Coins\" are\
    \ 1...1000\nfor i in range(1, 1001):\n    for j in range(i, 1001):\n        dp[j]\
    \ += dp[j-i]\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n \
    \   # Exclude case with just N\n    print((dp[N] - 1) % P)", comments: '5', difficulty: '10',
  empty: '1', hrdifficulty: Easy, memory: '918', name: Counting Summations, num: '76',
  path: 76-Counting-Summations, runtime: '12'}
'77': {code: "def primes(n):\n    \"\"\"Sieve of Eratosthenes\"\"\"\n    primes =\
    \ []\n    sieve = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if\
    \ sieve[p]:\n            primes.append(p)\n            # Cross out all multiples\
    \ of p\n            for i in range(p * p, n + 1, p):\n                sieve[i]\
    \ = False\n    return primes\n\n\ndef count(coins, n):\n    \"\"\"No. of ways\
    \ to write n\n    as a sum of elements of coins\"\"\"\n    # Initialize dp array\n\
    \    dp = [0] * (n+1)\n    # There is only one way to make nothing\n    dp[0]\
    \ = 1\n    for coin in coins:\n        for val in range(coin, n+1):\n        \
    \    dp[val] += dp[val-coin]\n    return dp\n\n\n# N <= 1000\nP = primes(1000)\n\
    COUNT = count(P, 1000)\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n\
    \    print(COUNT[N])", comments: '4', difficulty: '25', empty: '4', hrdifficulty: Easy,
  memory: '918', name: Counting Summations, num: '77', path: 77-Prime-Summations,
  runtime: '3'}
'78': {code: "def sgn(n):\n\t\treturn 1 if (n//2)%2 == 0 else -1\n\ndef pent(n):\n\
    \tout = [1]\n\ti = 1\n\tsign = True\n\twhile out[-1] <= n:\n\t\ti += 1\n\t\tsign\
    \ = not sign\n\t\tk = i//2*(-1)**int(sign)\n\t\tout.append(k*(3*k - 1)//2)\n\t\
    del out[0]\n\treturn out\n\nMAX = int(6e4)\nPENT = pent(MAX)\nPART = [0] * (MAX\
    \ +1)\nPART[0] = 1\n# Report ans mod 10^9 + 7\nP = 1000000007\n\nfor n in range(MAX+1):\n\
    \tfor i,p in enumerate([x for x in PENT if x <= n]):\n\t\tPART[n] += sgn(i)*PART[n-p]\n\
    \tPART[n] %= P\n\nT = int(input())\nfor _ in range(T):\n\tN = int(input())\n\t\
    print(PART[N]", comments: '1', difficulty: '30', empty: '4', hrdifficulty: Medium,
  memory: '14390', name: Counting Summations, num: '78', path: 78-Coin-Partitions,
  runtime: '9074'}
'79': {difficulty: '5', hrdifficulty: Hard, name: Passcode derivation, num: '79'}
'8': {code: "def substrings(s, k):\n    \"\"\"Find k-length substrings of string s\"\
    \"\"\n    out = []\n    n = len(s)\n    for i in range(n-k+1):\n        out.append(s[i:i+k])\n\
    \    return out\n\n\ndef string_prod(s):\n    \"\"\"Find the product of the digits\
    \ of an integer\n    given its string representation s\"\"\"\n    ans = 1\n  \
    \  for x in s:\n        ans *= int(x)\n    return ans\n\n\nT = int(input())\n\
    for _ in range(T):\n    N, K = map(int, input().split())\n    S = input().strip()\n\
    \    # Brute force each substring\n    ans = max([string_prod(x) for x in substrings(S,\
    \ K)])\n    print(ans)", comments: '1', difficulty: '5', empty: '4', hrdifficulty: Easy,
  memory: '934', name: Largest Product in a Series, num: '8', path: 8-Largest-Product-in-a-Series,
  runtime: '2'}
'80': {difficulty: '20', hrdifficulty: Easy, name: Square root digital expansion,
  num: '80'}
'81': {code: "N = int(input())\nG = [list(map(int, input().split())) for _ in range(N)]\n\
    \n# MPS = minimal path sum\n# Find MPS for bottom row and rightmost col\nfor i\
    \ in range(N-2, -1, -1):\n    G[N-1][i] += G[N-1][i+1]\n    G[i][N-1] += G[i+1][N-1]\n\
    \n# Find MPS for each square starting at bot-right\nfor i in range(N-2, -1, -1):\n\
    \    for j in range(N-2, -1, -1):\n        G[i][j] += min(G[i+1][j], G[i][j+1])\n\
    \n# Return topleft value\nprint(G[0][0])", comments: '4', difficulty: '10', empty: '3',
  hrdifficulty: Easy, memory: '949', name: 'Path sum: two ways', num: '81', path: 81-Path-Sum-Two-Ways,
  runtime: '6'}
'82': {difficulty: '20', hrdifficulty: Easy, name: 'Path sum: three ways', num: '82'}
'83': {difficulty: '25', hrdifficulty: Hard, name: 'Path sum: four ways', num: '83'}
'84': {difficulty: '35', hrdifficulty: Hard, name: Monopoly odds, num: '84'}
'85': {difficulty: '15', hrdifficulty: Medium, name: Counting rectangles, num: '85'}
'86': {difficulty: '35', hrdifficulty: Hard, name: Cuboid route, num: '86'}
'87': {difficulty: '20', hrdifficulty: Easy, name: Prime power triples, num: '87'}
'88': {difficulty: '40', hrdifficulty: Easy, name: Product-sum numbers, num: '88'}
'89': {difficulty: '20', hrdifficulty: Easy, name: Roman numerals, num: '89'}
'9': {code: "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    ans =\
    \ -1\n    # a can't be more than a third the perimeter\n    for a in range(1,\
    \ N//3):\n        b = (N**2 - 2*a*N)/(2*N - 2*a)\n        c = N - a - b\n    \
    \    # Check that Pythagorean identity holds\n        if b == int(b) and c ==\
    \ int(c) and c*c == a*a + b*b:\n            # Keep maximal product\n         \
    \   ans = max(ans, int(a*b*c))\n    print(ans)", comments: '3', difficulty: '5',
  empty: '0', hrdifficulty: Easy, memory: '929', name: Special Pythagorean Triplets,
  num: '9', path: 9-Special-Pythagorean-Triplet, runtime: '2'}
'90': {difficulty: '40', hrdifficulty: Easy, name: Cube digit pairs, num: '90'}
'91': {difficulty: '25', hrdifficulty: Medium, name: Right triangles with integer
    coordinates, num: '91'}
'92': {difficulty: '5', hrdifficulty: Easy, name: Square digit chains, num: '92'}
'93': {difficulty: '35', hrdifficulty: Medium, name: Arithmetic expressions, num: '93'}
'94': {difficulty: '35', hrdifficulty: Hard, name: Almost equilateral triangles, num: '94'}
'95': {difficulty: '30', hrdifficulty: Medium, name: Amicable chains, num: '95'}
'96': {difficulty: '25', hrdifficulty: Hard, name: Su Doku, num: '96'}
'97': {difficulty: '5', hrdifficulty: Hard, name: Large non-Mersenne prime, num: '97'}
'98': {difficulty: '35', hrdifficulty: Easy, name: Anagramic squares, num: '98'}
'99': {difficulty: '10', hrdifficulty: Medium, name: Largest exponential, num: '99'}
